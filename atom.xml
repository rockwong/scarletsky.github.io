<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scarletsky</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scarletsky.github.io/"/>
  <updated>2016-12-01T14:17:54.000Z</updated>
  <id>http://scarletsky.github.io/</id>
  
  <author>
    <name>Scarletsky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Restful API 中的错误处理</title>
    <link href="http://scarletsky.github.io/2016/11/30/error-handling-in-restful-api/"/>
    <id>http://scarletsky.github.io/2016/11/30/error-handling-in-restful-api/</id>
    <published>2016-11-30T09:02:18.000Z</published>
    <updated>2016-12-01T14:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>随着移动开发和前端开发的崛起，越来越多的 Web 后端应用都倾向于实现 Restful API。<br>Restful API 是一个简单易用的前后端分离方案，它只需要对客户端请求进行处理，然后返回结果即可， 无需考虑页面渲染，一定程度上减轻了后端开发人员的负担。<br>然而，正是由于 Restful API 不需要考虑页面渲染，导致它不能在页面上展示错误信息。<br>那就意着当出现错误的时候，它只能通过返回一个错误的响应，来告诉用户和开发者相应的错误信息，提示他们接下来应该怎么办。<br>本文将讨论 Restful API 中的错误处理方案。</p>
<h2 id="设计错误信息"><a href="#设计错误信息" class="headerlink" title="设计错误信息"></a>设计错误信息</h2><p>当 Restful API 需要抛出错误的时候，我们要考虑的是：这个错误应该包含哪些信息。<br>我们先看看 Github, Google, Facebook, Twitter, Twilio 的错误信息是怎样的。</p>
<p>Github (use http status)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"message"</span>: <span class="string">"Validation Failed"</span>,</div><div class="line">  <span class="attr">"errors"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"resource"</span>: <span class="string">"Issue"</span>,</div><div class="line">      <span class="attr">"field"</span>: <span class="string">"title"</span>,</div><div class="line">      <span class="attr">"code"</span>: <span class="string">"missing_field"</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Google (use http status)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"error"</span>: &#123;</div><div class="line">    <span class="attr">"errors"</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"domain"</span>: <span class="string">"global"</span>,</div><div class="line">        <span class="attr">"reason"</span>: <span class="string">"insufficientFilePermissions"</span>,</div><div class="line">        <span class="attr">"message"</span>: <span class="string">"The user does not have sufficient permissions for file &#123;fileId&#125;."</span></div><div class="line">      &#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">"code"</span>: <span class="number">403</span>,</div><div class="line">    <span class="attr">"message"</span>: <span class="string">"The user does not have sufficient permissions for file &#123;fileId&#125;."</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Facebook (use http status)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"error"</span>: &#123;</div><div class="line">    <span class="attr">"message"</span>: <span class="string">"Message describing the error"</span>, </div><div class="line">    <span class="attr">"type"</span>: <span class="string">"OAuthException"</span>,</div><div class="line">    <span class="attr">"code"</span>: <span class="number">190</span>,</div><div class="line">    <span class="attr">"error_subcode"</span>: <span class="number">460</span>,</div><div class="line">    <span class="attr">"error_user_title"</span>: <span class="string">"A title"</span>,</div><div class="line">    <span class="attr">"error_user_msg"</span>: <span class="string">"A message"</span>,</div><div class="line">    <span class="attr">"fbtrace_id"</span>: <span class="string">"EJplcsCHuLu"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Twitter (use http status)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"errors"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"message"</span>: <span class="string">"Sorry, that page does not exist"</span>,</div><div class="line">      <span class="attr">"code"</span>: <span class="number">34</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Twilio (use http status)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"code"</span>: <span class="number">21211</span>,</div><div class="line">  <span class="attr">"message"</span>: <span class="string">"The 'To' number 5551234567 is not a valid phone number."</span>,</div><div class="line">  <span class="attr">"more_info"</span>: <span class="string">"https://www.twilio.com/docs/errors/21211"</span>,</div><div class="line">  <span class="attr">"status"</span>: <span class="number">400</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察这些结构可以发现它们都有一些共同的地方：</p>
<ul>
<li>都利用了 Http 状态码</li>
<li>有些返回了业务错误码</li>
<li>都提供了给用户看的错误提示信息</li>
<li>有些提供了给开发者看的错误信息</li>
</ul>
<h3 id="Http-状态码"><a href="#Http-状态码" class="headerlink" title="Http 状态码"></a>Http 状态码</h3><p>在 Restful API 中利用 Http 状态码来表明错误类型再合适不过了，因为 Http 状态码定义了很多抽象的错误类型。<br>虽然 Http 状态码定义了非常多的错误类型，但实际应用中，我们常用的状态码并不多，通常都是下面这几方面：</p>
<ul>
<li>API 正常工作 (200, 201)</li>
<li>客户端错误 (400, 401, 403, 404)</li>
<li>服务端错误 (500, 503)</li>
</ul>
<h3 id="业务错误码"><a href="#业务错误码" class="headerlink" title="业务错误码"></a>业务错误码</h3><p>很多时候，我们根据业务类型来自定义错误码。<br>这些业务错误码与 Http 状态码并不重叠，这时候我们可以返回业务错误码，用来提示用户/开发者错误类型。</p>
<h3 id="给用户看的错误信息"><a href="#给用户看的错误信息" class="headerlink" title="给用户看的错误信息"></a>给用户看的错误信息</h3><p>当出现错误的时候，我们需要提示用户如何处理这种情况，通常这种错误信息都是必须的。<br>可以看到上面几个例子中都有返回给用户看的错误信息。</p>
<h3 id="给开发者看的错误信息"><a href="#给开发者看的错误信息" class="headerlink" title="给开发者看的错误信息"></a>给开发者看的错误信息</h3><p>若我们的 API 需要开放给第三方开发者，那么我们就需要考虑返回一些给开发者看的错误信息。</p>
<h2 id="设计错误类型"><a href="#设计错误类型" class="headerlink" title="设计错误类型"></a>设计错误类型</h2><p>我们刚才提到过，可以利用 Http 状态码来为错误类型进行分类。<br>通常我们所说的分类通常是对客户端错误进行分类， 即 4xx 类型的错误。</p>
<p>而这些错误类型中，我们最常用的是：</p>
<ul>
<li><p>400 Bad Request<br>由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>通常在请求参数不合法或格式错误的时候可以返回这个状态码。</p>
</li>
<li><p>401 Unauthorized<br>当前请求需要用户验证。<br>通常在没有登录的状态下访问一些受保护的 API 时会用到这个状态码。</p>
</li>
<li><p>403 Forbidden<br>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助。<br>通常在没有权限操作资源时(如修改/删除一个不属于该用户的资源时)会用到这个状态码。</p>
</li>
<li><p>404 Not Found<br>请求失败，请求所希望得到的资源未被在服务器上发现。<br>通常在找不到资源时返回这个状态码。</p>
</li>
</ul>
<p>尽管我们可以通过 Http 状态码来表示错误的类型，<br>但在实际应用中，如果仅仅使用 Http 状态码的话，我们的代码中就遍布 Http 状态码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Node.js</span></div><div class="line"><span class="keyword">if</span> (!res.body.title) &#123;</div><div class="line">  res.statusCode = <span class="number">400</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!user) &#123;</div><div class="line">  res.statusCode = <span class="number">401</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!post) &#123;</div><div class="line">  res.statusCode = <span class="number">404</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的实现方式在小项目中还可以接受，当项目变大、需求变多的时候，维护起来就变得很麻烦了。<br>为了提高错误的可读性和可维护性，我们需要对各种错误进行分类。<br>我个人习惯把错误分成以下几种类型：</p>
<ul>
<li>格式错误 (FORMAT_INVALID)</li>
<li>数据不存在 (DATA_NOT_FOUND)</li>
<li>数据已存在 (DATA_EXISTED)</li>
<li>数据无效 (DATA_INVALID)</li>
<li>登录错误 (LOGIN_REQUIRED)</li>
<li>权限不足 (PERMISSION_DENIED)</li>
</ul>
<p>错误分类之后，我们抛错误的时候就变得更加直观了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (!res.body.title) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ERROR.FORMAT_INVALID)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!user) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ERROR.LOGIN_REQUIRED)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!post) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ERROR.DATA_NOT_FOUND)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (post.creator.id !== user.id) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(ERROR.PERMISSION_DENIED)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种形式比上面的写死状态码的方式方便很多，而且维护起来也更加简单。<br>但有一个问题，就是不能根据错误类型来返回指定的错误信息。</p>
<h2 id="自定义错误类型"><a href="#自定义错误类型" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h2><p>要实现根据错误类型来返回指定的错误信息，我们可以通过自定义错误的方式来实现。<br>假设我们自定义错误的结构如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"type"</span>: <span class="string">""</span>,</div><div class="line">  <span class="attr">"code"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"message"</span>: <span class="string">""</span>,</div><div class="line">  <span class="attr">"detail"</span>: <span class="string">""</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们需要做到如下几点：</p>
<ul>
<li>根据错误类型来自动设置 <code>type</code>, <code>code</code>, <code>message</code></li>
<li><code>detail</code> 为可选项，用来描述该错误的具体原因</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> ERROR = &#123;</div><div class="line">  <span class="attr">FORMAT_INVALID</span>: <span class="string">'FORMAT_INVALID'</span>,</div><div class="line">  <span class="attr">DATA_NOT_FOUND</span>: <span class="string">'DATA_NOT_FOUND'</span>,</div><div class="line">  <span class="attr">DATA_EXISTED</span>: <span class="string">'DATA_EXISTED'</span>,</div><div class="line">  <span class="attr">DATA_INVALID</span>: <span class="string">'DATA_INVALID'</span>,</div><div class="line">  <span class="attr">LOGIN_REQUIRED</span>: <span class="string">'LOGIN_REQUIRED'</span>,</div><div class="line">  <span class="attr">PERMISSION_DENIED</span>: <span class="string">'PERMISSION_DENIED'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> ERROR_MAP = &#123;</div><div class="line">  <span class="attr">FORMAT_INVALID</span>: &#123;</div><div class="line">    <span class="attr">code</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'The request format is invalid'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">DATA_NOT_FOUND</span>: &#123;</div><div class="line">    <span class="attr">code</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'The data is not found in database'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">DATA_EXISTED</span>: &#123;</div><div class="line">    <span class="attr">code</span>: <span class="number">3</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'The data has exist in database'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">DATA_INVALID</span>: &#123;</div><div class="line">    <span class="attr">code</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'The data is invalid'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">LOGIN_REQUIRED</span>: &#123;</div><div class="line">    code <span class="number">5</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'Please login first'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">PERMISSION_DENIED</span>: &#123;</div><div class="line">    <span class="attr">code</span>: <span class="number">6</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'You have no permission to operate'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(type, detail) &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="built_in">Error</span>.captureStackTrace(<span class="keyword">this</span>, <span class="keyword">this</span>.constructor)</div><div class="line"></div><div class="line">    <span class="keyword">let</span> error = ERROR_MAP[type]</div><div class="line">    <span class="keyword">if</span> (!error) &#123;</div><div class="line">      error = &#123;</div><div class="line">        <span class="attr">code</span>: <span class="number">999</span>,</div><div class="line">        <span class="attr">message</span>: <span class="string">'Unknow error type'</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'CError'</span></div><div class="line">    <span class="keyword">this</span>.type = error.code !== <span class="number">999</span> ? type : <span class="string">'UNDEFINED'</span></div><div class="line">    <span class="keyword">this</span>.code = error.code</div><div class="line">    <span class="keyword">this</span>.message = error.message</div><div class="line">    <span class="keyword">this</span>.detail = detail</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义好错误之后，我们调用起来就更加简单了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// in controller</span></div><div class="line"><span class="keyword">if</span> (!user) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> CError(ERROR.LOGIN_REQUIRED, <span class="string">'You should login first'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!req.body.title) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> CError(ERROR.FORMAT_INVALID, <span class="string">'Title is required'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!post) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> CError(ERROR.DATA_NOT_FOUND, <span class="string">'The post you required is not found'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，还剩下一个问题，根据错误类型来设置状态码，然后返回错误信息给客户端。</p>
<h2 id="捕获错误信息"><a href="#捕获错误信息" class="headerlink" title="捕获错误信息"></a>捕获错误信息</h2><p>在 Controller 中抛出自定义错误后，我们需要捕获该错误，才能返回给客户端。<br>假设我们使用 koa 2 作为 web 框架来开发 restful api，那么我们要做的是添加错误处理的中间件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span> (<span class="params">ctx, next</span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">await</span> next()</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> status</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (err.type) &#123;</div><div class="line">      <span class="keyword">case</span> ERROR.FORMAT_INVALID:</div><div class="line">      <span class="keyword">case</span> ERROR.DATA_EXISTED:</div><div class="line">      <span class="keyword">case</span> ERROR.DATA_INVALID:</div><div class="line">        status = <span class="number">400</span></div><div class="line">        <span class="keyword">break</span></div><div class="line">      <span class="keyword">case</span> ERROR.LOGIN_REQUIRED:</div><div class="line">        status = <span class="number">401</span></div><div class="line">      <span class="keyword">case</span> ERROR.PERMISSION_DENIED:</div><div class="line">        status = <span class="number">403</span></div><div class="line">      <span class="keyword">case</span> ERROR.DATA_NOT_FOUND:</div><div class="line">        status = <span class="number">404</span></div><div class="line">        <span class="keyword">break</span></div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        status = <span class="number">500</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ctx.status = status</div><div class="line">    ctx.body = err</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// in app.js</span></div><div class="line">app.use(errorHandler)</div><div class="line">app.use(router.routes())</div></pre></td></tr></table></figure>
<p>通过这种方式，我们就能优雅地处理 Restful API 中的错误信息了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/zh-hans/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="external">https://zh.wikipedia.org/zh-hans/HTTP%E7%8A%B6%E6%80%81%E7%A0%81</a><br><a href="https://www.loggly.com/blog/node-js-error-handling/" target="_blank" rel="external">https://www.loggly.com/blog/node-js-error-handling/</a><br><a href="http://blog.restcase.com/rest-api-error-codes-101/" target="_blank" rel="external">http://blog.restcase.com/rest-api-error-codes-101/</a><br><a href="https://apigee.com/about/blg/technology/restful-api-design-what-about-errors" target="_blank" rel="external">https://apigee.com/about/blg/technology/restful-api-design-what-about-errors</a><br><a href="http://stackoverflow.com/questions/942951/rest-api-error-return-good-practices" target="_blank" rel="external">http://stackoverflow.com/questions/942951/rest-api-error-return-good-practices</a><br><a href="http://goldbergyoni.com/checklist-best-practices-of-node-js-error-handling/" target="_blank" rel="external">http://goldbergyoni.com/checklist-best-practices-of-node-js-error-handling/</a><br><a href="http://blogs.mulesoft.com/dev/api-dev/api-best-practices-response-handling/" target="_blank" rel="external">http://blogs.mulesoft.com/dev/api-dev/api-best-practices-response-handling/</a><br><a href="https://developers.facebook.com/docs/graph-api/using-graph-api/#errors" target="_blank" rel="external">https://developers.facebook.com/docs/graph-api/using-graph-api/#errors</a><br><a href="https://developers.google.com/drive/v3/web/handle-errors" target="_blank" rel="external">https://developers.google.com/drive/v3/web/handle-errors</a><br><a href="https://developer.github.com/v3/#client-errors" target="_blank" rel="external">https://developer.github.com/v3/#client-errors</a><br><a href="https://dev.twitter.com/overview/api/response-codes" target="_blank" rel="external">https://dev.twitter.com/overview/api/response-codes</a><br><a href="https://www.twilio.com/docs/api/errors" target="_blank" rel="external">https://www.twilio.com/docs/api/errors</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;随着移动开发和前端开发的崛起，越来越多的 Web 后端应用都倾向于实现 Restful API。&lt;br&gt;Restful API 是一个简单易
    
    </summary>
    
    
      <category term="restful, error handling" scheme="http://scarletsky.github.io/tags/restful-error-handling/"/>
    
  </entry>
  
  <entry>
    <title>在 Node.js 中为 Restful API 编写单元测试</title>
    <link href="http://scarletsky.github.io/2016/10/05/write-unit-tests-for-restful-api-in-nodejs/"/>
    <id>http://scarletsky.github.io/2016/10/05/write-unit-tests-for-restful-api-in-nodejs/</id>
    <published>2016-10-05T03:57:26.000Z</published>
    <updated>2016-10-05T02:22:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单元测试是针对程序模块来进行正确性检验的测试工作，程序单元是应用的最小可测试部件。<br>在 Web 应用中，我们可以把 Restful API 看作是构成应用的单元。<br>Restful API 比较好测试，测试起来也比较简单。<br>本文将介绍编写测试的原因和原则，然后以 Node.js 为例子介绍测试 Restful API 的方法。</p>
<h2 id="为什么要编写测试"><a href="#为什么要编写测试" class="headerlink" title="为什么要编写测试"></a>为什么要编写测试</h2><p>每个开发者都知道单元测试的重要性，但并不是每个开发者都会去编写单元测试。原因也很容易理解：</p>
<ul>
<li>编写测试需要更多的时间，会拖慢项目进度</li>
<li>编写测试需要写更多的代码，更容易出现错误</li>
<li>当需求更变后，我们要花更多的精力去修改测试代码</li>
<li>有时候测试代码可能会比源代码多几倍</li>
</ul>
<p>我以前也抱有类似的想法，认为人工测试就足够了，没必要特意去编写单元测试。<br>然而随着项目的规模的增大，代码也会慢慢出现意外。<br>最典型的例子是为了某需求修改了 A 位置，需求完成了，而 B 位置就出现了 Bug。</p>
<p>在读过 <a href="http://www.yinwang.org/blog-cn/2016/09/14/tests" target="_blank" rel="external">王垠大神的《测试的道理》</a> 之后，我更加明白了一个道理：我没有大神般的编码能力，我只能通过单元测试来检验自己的编码。</p>
<p>除了检验代码的正确性之外，我认为单元测试还有一个很重要的作用：为日后重构项目做准备。<br>只要单元测试覆盖得够好，以后重构的时候就很容易发现问题，节约大量的时间。</p>
<p>轮子哥在 <a href="https://www.zhihu.com/question/28729261/answer/94964928" target="_blank" rel="external">知乎</a> 上说过一句很有意思的话：</p>
<blockquote>
<p>所以那些专门写不需要维护的软件的人，讨厌测试，也是情有可原的。</p>
</blockquote>
<p>如果你要编写一个长期维护的软件，那么你最好添加单元测试。</p>
<h2 id="F-I-R-S-T-原则"><a href="#F-I-R-S-T-原则" class="headerlink" title="F.I.R.S.T 原则"></a>F.I.R.S.T 原则</h2><p>当我们决定要编写单元测试之后，我们就要考虑怎样 <strong>写好</strong> 单元测试，换句话说就是编写单元测试时需要注意哪些原则。<br>那么，有哪些原则是我们需要注意的呢？</p>
<ul>
<li><strong>Fast</strong>: 测试必须是快速的</li>
<li><strong>Isolated / Independent</strong>: <ul>
<li>每个测试都要做 3 A =&gt; Arrange(准备), Act(行动), Assert(断言)</li>
<li>Arrange: 测试过程中用到的数据不能依赖于运行环境，测试中用到的数据应是测试中的一部分</li>
<li>Act: 调用你想要测试的方法 / API</li>
<li>Assert: 根据返回结果进行断言</li>
<li>测试结果不能依赖运行环境</li>
<li>测试结果不依赖运行测试的顺序</li>
</ul>
</li>
<li><strong>Repeatable</strong>:<ul>
<li>每个测试必须是可重复执行的，即运行 N 次，会得到 N 次相同的结果</li>
<li>每个测试的结果不应依赖时间，日期，和随机数的输出</li>
</ul>
</li>
<li><strong>Self-validating</strong>: <ul>
<li>每个测试都可以自己判断结果来判断测试是否通过</li>
<li>不需要人类去查阅手册来判断结果</li>
</ul>
</li>
<li><strong>Thorough and Timely</strong>:<ul>
<li>应该尽量覆盖所有使用场景</li>
<li>应该尝试测试驱动开发(TDD)</li>
</ul>
</li>
</ul>
<p>这就是经典的 F.I.R.S.T 原则。<br>我们最好时刻注意自己编写的单元测试是否遵守这些原则。</p>
<p>JavaScript 社区里有很多测试框架可以用来编写单元测试，有 <code>ava</code>、<code>mocha</code>、<code>jasmine</code>、<code>tap</code> 等。<br>这些测试框架都有提供 <code>beforeEach</code>、<code>afterEach</code> API，目的是隔离我们的测试数据，从而满足 <strong>Isolated / Independent</strong> 和 <strong>Repeatable</strong> 原则。</p>
<h2 id="编写单元测试"><a href="#编写单元测试" class="headerlink" title="编写单元测试"></a>编写单元测试</h2><p>假设我们有以下 Restful API (用了 jwt 来做用户验证):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router()</div><div class="line"><span class="comment">// 根据 token 获取用户信息，必须登录</span></div><div class="line">router.get(<span class="string">'/user'</span>, jwt, user.getSelf)</div><div class="line"><span class="comment">// 获取用户列表，无需登录</span></div><div class="line">router.get(<span class="string">'/users'</span>, user.getList)</div><div class="line"><span class="comment">// 获取指定用户信息，无需登录</span></div><div class="line">router.get(<span class="string">'/users/:userId'</span>, user.get)</div><div class="line"><span class="comment">// 创建新用户(用户注册)，无需登录</span></div><div class="line">router.post(<span class="string">'/users'</span>, user.create)</div><div class="line"><span class="comment">// 更新用户信息，必须登录</span></div><div class="line">router.put(<span class="string">'/user'</span>, jwt, user.update)</div></pre></td></tr></table></figure>
<p>那么我们应该怎样为这些 Restful API 编写单元测试呢？</p>
<p>最基本流程是：</p>
<ul>
<li>为 app 创建 http 服务器</li>
<li>对各个 API 发出请求</li>
<li>对响应内容进行断言</li>
</ul>
<p>幸运的是，社区里已经有相应的工具让我们可以方便管理这个流程，这个工具就是 —— <code>supertest</code>。<br>它提供了非常灵活的 API，足以帮助我们测试 Restful API 了。<br>基本用法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'../app'</span>)</div><div class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'supertest'</span>)(app)</div><div class="line"></div><div class="line">request</div><div class="line">  .get(<span class="string">'/users'</span>)</div><div class="line">  .expect(<span class="number">200</span>)</div><div class="line">  .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</div><div class="line">    res.body.should.be.an.Array()</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>提示<br>如果你遇到了 <code>TypeError: app.address is not a function</code>, 请尝试一下以下方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'supertest'</span>).agent(app.listen())</div></pre></td></tr></table></figure></p>
</blockquote>
<p>现在，我们可以把 <code>supertest</code> 和其他测试框架整合起来了，我选择了 <code>mocha</code> 作为例子，因为它很经典，当你会用 <code>mocha</code> 之后，其他测试框架基本上就难不倒你了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</div><div class="line"><span class="keyword">const</span> &#123; ObjectId &#125; = <span class="built_in">require</span>(<span class="string">'mongoose'</span>).Types</div><div class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</div><div class="line"><span class="keyword">const</span> UserModel = <span class="built_in">require</span>(<span class="string">'../models/user'</span>)</div><div class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'../app'</span>)</div><div class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'supertest'</span>)(app)</div><div class="line"></div><div class="line">describe(<span class="string">'User API'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 为每个单元测试初始化数据</span></div><div class="line">  <span class="comment">// 每个单元测试中可以通过 context 来访问相关的数据</span></div><div class="line">  beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">      self.user1 = <span class="keyword">yield</span> UserModel.create(&#123; <span class="attr">username</span>: <span class="string">'user1'</span> &#125;)</div><div class="line">      self.token = jwt.sign(&#123; <span class="attr">_id</span>: self.user1._id &#125;, config.jwtSecret, &#123; <span class="attr">expiresIn</span>: <span class="number">3600</span> &#125;)</div><div class="line">      done()</div><div class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'err: '</span>, err)</div><div class="line">      done()</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 正常情况下访问 /user</span></div><div class="line">  it(<span class="string">'should get user info when GET /user with token'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span></div><div class="line">    request</div><div class="line">      .get(<span class="string">'/user'</span>)</div><div class="line">      .set(<span class="string">'Authorization'</span>, self.token)</div><div class="line">      .expect(<span class="number">200</span>)</div><div class="line">      .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</div><div class="line">        res.body._id.should.equal(self.user1._id)</div><div class="line">        done()</div><div class="line">      &#125;)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 非正常情况下访问 /user</span></div><div class="line">  it(<span class="string">'should return 403 when GET /user without token'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    request</div><div class="line">      .get(<span class="string">'/user'</span>)</div><div class="line">      .expect(<span class="number">403</span>, done)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 访问 /users，登录用户和非登录用户都会得到相同的结果，所以不需要区别对待</span></div><div class="line">  it(<span class="string">'should return user list when GET /users'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    request</div><div class="line">      .get(<span class="string">'/users'</span>)</div><div class="line">      .expect(<span class="number">200</span>)</div><div class="line">      .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</div><div class="line">        res.body.should.be.an.Array()</div><div class="line">        done()</div><div class="line">      &#125;)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 访问 /users/:userId 也不需要区分登录和非登录状态</span></div><div class="line">  it(<span class="string">'should return user info when GET /users/:userId'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span></div><div class="line">    request</div><div class="line">      .get(<span class="string">`/users/<span class="subst">$&#123;self.user1._id&#125;</span>`</span>)</div><div class="line">      .expect(<span class="number">200</span>)</div><div class="line">      .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</div><div class="line">        res.body._id.should.equal(self.user1._id)</div><div class="line">        done()</div><div class="line">      &#125;)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 访问不存在的用户，我们需要构造一个虚假的用户 id</span></div><div class="line">  it(<span class="string">'should return 404 when GET /users/$&#123;non-existent&#125;'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    request</div><div class="line">      .get(<span class="string">`/users/<span class="subst">$&#123;ObjectId()&#125;</span>`</span>)</div><div class="line">      .expect(<span class="number">404</span>, done)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 正常情况下的用户注册不会带上 token</span></div><div class="line">  it(<span class="string">'should return user info when POST /user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> username = <span class="string">'test user'</span></div><div class="line">    request</div><div class="line">      .post(<span class="string">'/users'</span>)</div><div class="line">      .send(&#123; <span class="attr">username</span>: username &#125;)</div><div class="line">      .expect(<span class="number">200</span>)</div><div class="line">      .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</div><div class="line">        res.body.username.should.equal(username)</div><div class="line">        done()</div><div class="line">      &#125;)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 非法情况下的用户注册，带上了 token 的请求要判断为非法请求</span></div><div class="line">  it(<span class="string">'should return 400 when POST /user with token'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> username = <span class="string">'test user 2'</span></div><div class="line">    request</div><div class="line">      .post(<span class="string">'/users'</span>)</div><div class="line">      .set(<span class="string">'Authorization'</span>, <span class="keyword">this</span>.token)</div><div class="line">      .send(&#123; <span class="attr">username</span>: username &#125;)</div><div class="line">      .expect(<span class="number">400</span>, done)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 正常情况下更新用户信息，需要带上 token</span></div><div class="line">  it(<span class="string">'should return 200 when PUT /user with token'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    request</div><div class="line">      .put(<span class="string">'/user'</span>)</div><div class="line">      .set(<span class="string">'Authorization'</span>, <span class="keyword">this</span>.token)</div><div class="line">      .send(&#123; <span class="attr">username</span>: <span class="string">'valid username'</span> &#125;)</div><div class="line">      .expect(<span class="number">200</span>, done)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 非法情况下更新用户信息，如缺少 token</span></div><div class="line">  it(<span class="string">'should return 400 when PUT /user without token'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    request</div><div class="line">      .put(<span class="string">'/user'</span>)</div><div class="line">      .send(&#123; <span class="attr">username</span>: <span class="string">'valid username'</span> &#125;)</div><div class="line">      .expect(<span class="number">400</span>, done)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可以看到，为 Restful API 编写单元测试还有一个优点，就是可以轻易区分登录状态和非登录状态。如果要在用户界面中测试这些功能，那么就需要不停地登录和注销，将会是一项累人的工作~<br>另外，上面的例子中基本都是对返回状态吗进行断言的，你可以按照自己的需要进行断言。</p>
<blockquote>
<p>提示<br>你可以选择自己喜欢的断言库，我这里选择了 should.js，原因是好读。<br>个人认为 should.js 和其他断言库比起来有个缺点，就是不好写。<br>value.should.xxx.yyy.zzz 这个形式和 assert.equal(value, expected) 相比不太直观。<br>另外由于 should.js 是通过扩展 Object.prototype 的原型来实现的，但 null 值是一个例外，它不能访问任何属性。<br>因此 should.js 在 null 上会失效。<br>一个变通的办法是 <code>(value === null).should.equal(true)</code>。</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm test</div><div class="line"></div><div class="line">  User api</div><div class="line">    ✓ should get user info when GET /user with token</div><div class="line">    ✓ should return 403 when GET /user without token</div><div class="line">    ✓ should return user list when GET /users</div><div class="line">    ✓ should return user info when GET /users/:userId</div><div class="line">    ✓ should return 404 when GET /users/$&#123;non-existent&#125;</div><div class="line">    ✓ should return user info when POST /user</div><div class="line">    ✓ should return 400 when POST /user with token</div><div class="line">    ✓ should return 200 when PUT /user with token</div><div class="line">    ✓ should return 400 when PUT /user without token</div></pre></td></tr></table></figure>
<p>当我们运行测试时，看到自己编写的测试都通过时，心里都会非常踏实。<br>而当我们要对项目进行重构时，这些测试用例会帮我们发现重构过程中的问题，减少 Debug 时间，提升重构时的效率。</p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="如何连接测试数据库"><a href="#如何连接测试数据库" class="headerlink" title="如何连接测试数据库"></a>如何连接测试数据库</h3><p>在 Node.js 的环境下，我们可以设置环境变量 <code>NODE_ENV=test</code>，然后通过这个环境变量去连接测试数据库，这样测试数据就不会存在于开发环境下的数据库拉！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// config.js</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">development</span>: &#123;&#125;,</div><div class="line">  <span class="attr">production</span>: &#123;&#125;,</div><div class="line">  <span class="attr">test</span>: &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// app.js</span></div><div class="line"><span class="keyword">const</span> ENV = process.NODE_ENV || <span class="string">'development'</span></div><div class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./config'</span>)[ENV]</div><div class="line"><span class="comment">// connect db by config</span></div></pre></td></tr></table></figure>
<h3 id="如何清空测试数据库"><a href="#如何清空测试数据库" class="headerlink" title="如何清空测试数据库"></a>如何清空测试数据库</h3><p>清空数据库这种一次性的工作最好放到 npm scripts 中处理，需要进行清空操作的时候直接运行 <code>npm run resetDB</code> 就可以了。<br>需要注意的是，编写清空数据库脚本时必须判断环境变量 <code>NODE_ENV</code>，以免误删 production 环境下的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// resetDB.js</span></div><div class="line"><span class="keyword">const</span> env = process.NODE_ENV || <span class="string">'development'</span></div><div class="line"><span class="keyword">if</span> (env === <span class="string">'test'</span> || env === <span class="string">'development'</span>) &#123;</div><div class="line">  <span class="comment">// connect db and delete data</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'You can not run this script in production.'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// package.json</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"resetDB"</span>: <span class="string">"node scripts/resetDB.js"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="何时清空测试环境的数据库"><a href="#何时清空测试环境的数据库" class="headerlink" title="何时清空测试环境的数据库"></a>何时清空测试环境的数据库</h3><p>如果是按照上面的原则来生成测试数据的话，测试数据其实可以不用删掉的。<br>但由于测试数据会占用我们的空间，最好还是把这些测试数据删掉。<br>那么，清空测试数据库这个操作在测试前执行好，还是测试后执行好？<br>我个人倾向于测试前删除，因为有时候我们需要进入数据库，查看测试数据的正确性。<br>如果在测试后清空测试数据库的话，我们就没办法访问到测试数据了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"resetDB"</span>: <span class="string">"node scripts/resetDB.js"</span>,</div><div class="line">    <span class="string">"test"</span>: <span class="string">"NODE_ENV=test npm run resetDB &amp;&amp; mocha --harmony"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/zh-cn/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" target="_blank" rel="external">https://zh.wikipedia.org/zh-cn/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95</a><br><a href="http://blog.hubstaff.com/why-you-should-write-unit-tests/" target="_blank" rel="external">http://blog.hubstaff.com/why-you-should-write-unit-tests/</a><br><a href="http://www.yinwang.org/blog-cn/2016/09/14/tests" target="_blank" rel="external">http://www.yinwang.org/blog-cn/2016/09/14/tests</a><br><a href="https://www.zhihu.com/question/28729261/answer/94964928" target="_blank" rel="external">https://www.zhihu.com/question/28729261/answer/94964928</a><br><a href="http://agileinaflash.blogspot.de/2009/02/first.html" target="_blank" rel="external">http://agileinaflash.blogspot.de/2009/02/first.html</a><br><a href="http://howtodoinjava.com/best-practices/first-principles-for-good-tests/" target="_blank" rel="external">http://howtodoinjava.com/best-practices/first-principles-for-good-tests/</a><br><a href="https://github.com/ghsukumar/SFDC_Best_Practices/wiki/F.I.R.S.T-Principles-of-Unit-Testing" target="_blank" rel="external">https://github.com/ghsukumar/SFDC_Best_Practices/wiki/F.I.R.S.T-Principles-of-Unit-Testing</a><br><a href="https://github.com/sindresorhus/awesome-nodejs#testing" target="_blank" rel="external">https://github.com/sindresorhus/awesome-nodejs#testing</a><br><a href="https://github.com/visionmedia/supertest" target="_blank" rel="external">https://github.com/visionmedia/supertest</a><br><a href="https://yq.aliyun.com/articles/57804" target="_blank" rel="external">https://yq.aliyun.com/articles/57804</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;单元测试是针对程序模块来进行正确性检验的测试工作，程序单元是应用的最小可测试部件。&lt;br&gt;在 Web 应用中，我们可以把 Restful A
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
      <category term="nodejs" scheme="http://scarletsky.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>浅谈单页应用中前端分页的实现方案</title>
    <link href="http://scarletsky.github.io/2016/09/11/talking-about-front-end-pagination-implementation-in-spa/"/>
    <id>http://scarletsky.github.io/2016/09/11/talking-about-front-end-pagination-implementation-in-spa/</id>
    <published>2016-09-11T10:07:06.000Z</published>
    <updated>2016-09-11T15:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>分页是开发中最常见的需求之一。<br>对于分页，我们讨论的最多的是后端的数据库分页，这关乎到我们应用程序的性能，也是分页这个需求的核心。<br>而前端要做的，是把后端返回的数据呈现在页面上，工作被认为是简单琐碎的。<br>在单页应用中，我们有很多中分页方案，最常见的是无限滚动、上一页 &amp; 下一页和页码。<br>本文将谈谈这三种分页方式。</p>
<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><p>无论使用哪种分页方案，我们都需要处理一些通用的需求，如：</p>
<ul>
<li>解析 url，提取当前页面的参数</li>
<li>根据返回数据生成自定义 DOM</li>
<li>移除某个 Node 节点中的所有子元素</li>
<li>往某个 Node 节点中插入元素列表</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 解析 url 中的查询字符串</span></div><div class="line"><span class="comment">// 如 http://host/items?page=5 中提取 page=5 中的 5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePage</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> searchString = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).split(<span class="string">'&amp;'</span>).filter(<span class="function"><span class="params">v</span> =&gt;</span> v.indexOf(<span class="string">'page'</span>) !== <span class="number">-1</span>)[<span class="number">0</span>];</div><div class="line">    <span class="keyword">var</span> page = <span class="built_in">Number</span>(searchString.split(<span class="string">'='</span>)[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">isNaN</span>(page) ? <span class="number">1</span> : page;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生成自定义 DOM</span></div><div class="line"><span class="comment">// generateItemView :: Object -&gt; DOM Node</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateItemView</span>(<span class="params">object</span>) </span>&#123; <span class="comment">/* implementation */</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 移除 Node 中所有子节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeItems</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">while</span> (node.firstChild) &#123;</div><div class="line">        node.removeChild(node.firstChild);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 往 Node 中插入元素列表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertItems</span>(<span class="params">node, items</span>) </span>&#123;</div><div class="line">    items.forEach(<span class="function"><span class="params">item</span> =&gt;</span> node.appendChild(generateItemView(item)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下文的示例代码中会直接调用这些函数，不再重复定义。</p>
<h2 id="无限滚动"><a href="#无限滚动" class="headerlink" title="无限滚动"></a>无限滚动</h2><p>无论对从前端还是后端来说，无限滚动都是我认为最简单的分页方案。<br>对后端来说，按照 <code>page</code> 和 <code>limit</code> 直接查出范围，然后返回一个数组给前端即可，不需要像其他方案那样还要查询总数。<br>对前端来说，直接根据后端返回的数据进行拼接即可，当后端返回一个空数组时，可以认为已经到最后一页，这时候就不需要再发请求到后端了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 后端返回的数据结构</span></div><div class="line"><span class="comment">// GET /items?page=5</span></div><div class="line">&#123; <span class="attr">items</span>: [...] &#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 前端处理</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItems</span>(<span class="params">page</span>) </span>&#123;</div><div class="line">    fetch(<span class="string">`/items?page=<span class="subst">$&#123;page&#125;</span>`</span>)</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">if</span> (res.items.length &gt; <span class="number">0</span>) &#123;</div><div class="line">                insertItems(</div><div class="line">                    <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>),</div><div class="line">                    res.items</div><div class="line">                );</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                alert(<span class="string">'No more data'</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无限滚动虽然实现起来简单，用户体验也不错，但有一些致命的缺点：</p>
<ul>
<li>容易出现性能问题</li>
<li>容易丢失浏览进度</li>
</ul>
<p>目前有一些方案可以解决这些缺点：性能问题可以通过动态渲染来解决，而丢失浏览进度则可以通过简单的新开窗口来解决。</p>
<h2 id="上一页-amp-下一页"><a href="#上一页-amp-下一页" class="headerlink" title="上一页 &amp; 下一页"></a>上一页 &amp; 下一页</h2><p>这种分页方式和无限滚动比起来，会复杂一点点。<br>最主要是因为后端需要查询总数，然后根据当前页数来计算是否可以查询上一页或下一页。<br>当然，计算这部分可以在后端做，也可以在前端做。</p>
<h3 id="后端计算"><a href="#后端计算" class="headerlink" title="后端计算"></a>后端计算</h3><p>如果在后端计算，那么后端要做的事情就有：</p>
<ul>
<li>查询总数</li>
<li>计算 <code>hasPrev</code> 和 <code>hasNext</code></li>
<li>查询元素列表</li>
</ul>
<p>而前端方面则相对简单：</p>
<ul>
<li>根据后端返回的 <code>hasPrev</code> 和 <code>hasNext</code> 来判断是否需要显示上一页/下一页按钮</li>
<li>移除容器内的所有元素，再插入新的元素（即用新元素替换旧元素）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 后端返回数据结构</span></div><div class="line"><span class="comment">// GET /items?page=5</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// hasPrev 和 hasNext 都需要后端去查询总数，然后计算出来</span></div><div class="line">    hasPrev: <span class="literal">true</span>,</div><div class="line">    <span class="attr">hasNext</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">items</span>: [...]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 前端处理</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItems</span>(<span class="params">page</span>) </span>&#123;</div><div class="line">    fetch(<span class="string">`/items?page=<span class="subst">$&#123;page&#125;</span>`</span>)</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">            res.hasPrev</div><div class="line">                ? <span class="built_in">document</span>.getElementById(<span class="string">'prevButton'</span>).style.display = <span class="string">'block'</span></div><div class="line">                : <span class="built_in">document</span>.getElementById(<span class="string">'prevButton'</span>).style.display = <span class="string">'none'</span>;</div><div class="line"></div><div class="line">            res.hasNext</div><div class="line">                ? <span class="built_in">document</span>.getElementById(<span class="string">'nextButton'</span>).style.display = <span class="string">'block'</span></div><div class="line">                : <span class="built_in">document</span>.getElementById(<span class="string">'nextButton'</span>).style.display = <span class="string">'none'</span>;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</div><div class="line">            removeItems(container);</div><div class="line">            insertItems(container, res.items);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方案实现起来比较简单，但缺点是每次分页都需要查询总页数，浪费资源。</p>
<h3 id="前端计算"><a href="#前端计算" class="headerlink" title="前端计算"></a>前端计算</h3><p>如果是前端计算的话，那么后端要做的事情就相对简单，只要再提供一个查询总数的接口即可。<br>而前端方面，需要做更多的事情，同时要考虑当前端数据丢失时（如用户刷新页面）的处理方案。</p>
<ul>
<li>第一次加载页面时需要调用一次查询总数的接口，同时调用获取元素的接口</li>
<li>返回数据后计算 <code>hasPrev</code> 和 <code>hasNext</code>，用来判断是否需要显示上一页/下一页按钮</li>
<li>移除容器内的所有元素，再插入新的元素（即用新元素替换旧元素）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 后端返回数据结构</span></div><div class="line"><span class="comment">// GET /itemsCount</span></div><div class="line">&#123; <span class="attr">total</span>: <span class="number">100</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// GET /items?page=5</span></div><div class="line">&#123; <span class="attr">items</span>: [...] &#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 前端处理</span></div><div class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> limit = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onload = getItemsCount(getItems);</div><div class="line"></div><div class="line"><span class="comment">// 获取总数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItemsCount</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    fetch(<span class="string">'/itemsCount'</span>)</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">            total = res.total;</div><div class="line">            callback.call(<span class="literal">null</span>, parsePage());</div><div class="line">        &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItems</span>(<span class="params">page</span>) </span>&#123;</div><div class="line">    fetch(<span class="string">`/items?page=<span class="subst">$&#123;page&#125;</span>`</span>)</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">var</span> hasPrev = page != <span class="number">1</span>;</div><div class="line">            <span class="keyword">var</span> hasNext = page != <span class="built_in">Math</span>.ceil(total / limit);</div><div class="line">            hasPrev</div><div class="line">                ? <span class="built_in">document</span>.getElementById(<span class="string">'prevButton'</span>).style.display = <span class="string">'block'</span></div><div class="line">                : <span class="built_in">document</span>.getElementById(<span class="string">'prevButton'</span>).style.display = <span class="string">'none'</span>;</div><div class="line"></div><div class="line">            hasNext</div><div class="line">                ? <span class="built_in">document</span>.getElementById(<span class="string">'nextButton'</span>).style.display = <span class="string">'block'</span></div><div class="line">                : <span class="built_in">document</span>.getElementById(<span class="string">'nextButton'</span>).style.display = <span class="string">'none'</span>;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</div><div class="line">            removeItems(container);</div><div class="line">            insertItems(container, res.items);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方案可以让后端甩锅给前端，前端的活又变多拉！</p>
<h2 id="页码"><a href="#页码" class="headerlink" title="页码"></a>页码</h2><p>最后我们谈谈页码分页。<br>这个方案和「上一页 &amp; 下一页」的方案很类似，不同的地方在于这个方案需要根据当前页面和总数来生成页码。<br>生成页码是这个方案最麻烦的地方。举个简单的例子，假设我们的数据有 50 页，我们不可能把所有页码都显示出来，需要生成一组不连续的页码。</p>
<p>我们可以采用下面的形式来显示页面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ------------------------------</span></div><div class="line"><span class="comment">// 我个人比较喜欢用 -1 来表示省略的区域</span></div><div class="line"><span class="comment">// 在生成 DOM 的时候，可以用省略号来展示</span></div><div class="line"><span class="comment">// ------------------------------</span></div><div class="line"><span class="comment">// 假设当前是第 1 页</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">50</span>]</div><div class="line"></div><div class="line"><span class="comment">// 假设当前是第 3 页</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">50</span>]</div><div class="line"></div><div class="line"><span class="comment">// 假设当前是第 25 页</span></div><div class="line">[<span class="number">1</span>, <span class="number">-1</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">-1</span>, <span class="number">50</span>]</div><div class="line"></div><div class="line"><span class="comment">// 假设当前是第 48 页</span></div><div class="line">[<span class="number">1</span>, <span class="number">-1</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>]</div><div class="line"></div><div class="line"><span class="comment">// 假设当前是第 50 页</span></div><div class="line">[<span class="number">1</span>, <span class="number">-1</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>]</div></pre></td></tr></table></figure>
<p>生成页码的原则通常都是：</p>
<ul>
<li>第一页和最后一页必须展示</li>
<li>其他页面按需展示，通常是当前页面的前后两页（即 x +- 2）</li>
<li>当页数少于 10 页的时候，直接显示出所有页码（为什么是 10 页？其实在满足前两个原则的情况下，只要 7 页省略号就会正常显示了。但页数较少的情况下显示省略号感觉怪怪的。）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> lastPage = <span class="built_in">Math</span>.ceil(total / limit);</div><div class="line"></div><div class="line"><span class="comment">// 根据当前页生成动态页码</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">genPages</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (lastPage &lt;= <span class="number">10</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(lastPage).fill().map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// dynamicPages 为除第一页和最后一页之外的页码，-1 表示省略号</span></div><div class="line">    <span class="keyword">var</span> dynamicPages;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (page === <span class="number">1</span>) &#123;</div><div class="line">        dynamicPages = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">-1</span>];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page === <span class="number">2</span>) &#123;</div><div class="line">        dynamicPages = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">-1</span>];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page === <span class="number">3</span>) &#123;</div><div class="line">        dynamicPages = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">-1</span>];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page === lastPage - <span class="number">2</span>) &#123;</div><div class="line">        dynamicPages = [<span class="number">-1</span>, page - <span class="number">2</span>, page - <span class="number">1</span>, page, page + <span class="number">1</span>];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page === lastPage - <span class="number">1</span>) &#123;</div><div class="line">        dynamicPages = [<span class="number">-1</span>, page - <span class="number">2</span>, page - <span class="number">1</span>, page];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page === lastPage) &#123;</div><div class="line">        dynamicPages = [<span class="number">-1</span>, page - <span class="number">2</span>, page - <span class="number">1</span>];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dynamicPages = [<span class="number">-1</span>, page - <span class="number">2</span>, page - <span class="number">1</span>, page, page + <span class="number">1</span>, page + <span class="number">2</span>, <span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dynamicPages.unshift(<span class="number">1</span>);</div><div class="line">    dynamicPages.push(lastPage);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dynamicPages;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成动态页码这部分的逻辑，无论放在前端还是后端都影响不大，可以按照自己需要去选择。<br>至于其他部分的细节，和「上一页 &amp; 下一页」类似，这里就不再重复了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/xitu/gold-miner/blob/master/TODO/ux-infinite-scrolling-vs-pagination.md" target="_blank" rel="external">https://github.com/xitu/gold-miner/blob/master/TODO/ux-infinite-scrolling-vs-pagination.md</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;分页是开发中最常见的需求之一。&lt;br&gt;对于分页，我们讨论的最多的是后端的数据库分页，这关乎到我们应用程序的性能，也是分页这个需求的核心。&lt;b
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>自定义 Redux 中的 combineReducers</title>
    <link href="http://scarletsky.github.io/2016/08/20/write-your-own-combine-reducers-in-redux/"/>
    <id>http://scarletsky.github.io/2016/08/20/write-your-own-combine-reducers-in-redux/</id>
    <published>2016-08-20T12:05:28.000Z</published>
    <updated>2016-08-24T03:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redux 中的 <code>combineReducers</code> 能让我们很方便地把多个 reducers 组合起来，成为一个新的 reducer。<br>然而，随着我们的应用变得越来越复杂，<code>combineReducers</code> 有可能不能满足我们的需求。<br>正如 Redux 官方文档所说:</p>
<blockquote>
<p>This helper is just a convenience! You can write your own combineReducers that works differently, or even assemble the state object from the child reducers manually and write a root reducing function explicitly, like you would write any other function.</p>
</blockquote>
<p><code>combineReducers</code> 只是方便我们使用而已，我们可以自定义一个完全不同的 <code>combineReducers</code> 来满足我们特殊的需求。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们先回忆一下 reducer 的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">oldState, action</span>) =&gt;</span> newState;</div></pre></td></tr></table></figure>
<p>reducer 是一个普通的函数，接受两个参数：<code>oldState</code> 和 <code>action</code>，然后返回一个 <code>newState</code>。<br>为了把多个 reducers 组合起来，我们通常会用 Redux 自带的 <code>combineReducers</code> 来实现:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</div><div class="line">  <span class="attr">key1</span>: key1Reducer,</div><div class="line">  <span class="attr">key2</span>: key2Reducer</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>先留意一下我们传了什么给 <code>combineReducers</code>:<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">key1</span>: <span class="function"><span class="keyword">function</span>(<span class="params">state.key1, action</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</div><div class="line">  <span class="attr">key2</span>: <span class="function"><span class="keyword">function</span>(<span class="params">state.key2, action</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，让我们先来想一想，经过 <code>combineReducers</code> 的处理之后，我们得到了什么呢？<br>不用想了，很显然我们得到了一个新的 reducer。<br>那这个新的 reducer 又长什么样呢？<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> rootReducer = <span class="function">(<span class="params">oldState, action</span>) =&gt;</span> newState;</div></pre></td></tr></table></figure></p>
<p>你应该不会惊讶，因为所有 reducer 都长这个样子，即使它是已经被组合过的 reducer，它也是长这个样子。<br>现在你应该猜到 <code>combineReducers</code> 做了什么了吧？其实它最基本形态是这样子的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它接受 <code>reducers</code> 作为参数，然后返回一个标准的 reducer 函数。</p>
<blockquote>
<p>注意:<br>其实到了这一步，我们就可以自定义 <code>combineReducers</code> 了，我们完全可以写一个类似的函数，然后在里面写各种 <code>switch...case</code> 语句来达到自定义的目的。<br>但我觉得我们还是先看看 Redux 自带的 <code>combineReducers</code> 做了什么比较好，因为我们自定义的 <code>combineReducers</code> 很有可能需要原来的功能。</p>
</blockquote>
<p>还记得我刚才叫你留意的地方吗？没错，就是下面这个:<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// reducers</span></div><div class="line">&#123;</div><div class="line">  <span class="attr">key1</span>: <span class="function"><span class="keyword">function</span>(<span class="params">state.key1, action</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</div><div class="line">  <span class="attr">key2</span>: <span class="function"><span class="keyword">function</span>(<span class="params">state.key2, action</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们来回想一下 <code>store.dispatch(action)</code> 的过程：当一个 <code>action</code> 触发的时候，所有 reducers 都应该响应这个 <code>action</code>，做出相应的改变，最后返回一个新的 <code>store</code>。<br>对着上面这个结构，我们其实很容易就能写出这样的效果，还能加上一些其他的处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reCombineReducers</span>(<span class="params">reducers</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">      <span class="keyword">case</span> SP_ACTION:</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123; <span class="comment">/* do something */</span> &#125;);</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(reducers)</div><div class="line">                    .map(<span class="function"><span class="params">k</span> =&gt;</span> (&#123; [k]: reducers[k](state[k], action) &#125;))</div><div class="line">                    .reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, prev, next));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子模拟了原来 <code>combineReducers</code> 的功能，还对 <code>SP_ACTION</code> 进行了特殊的处理，很简单吧！</p>
<p>然而，上面的例子虽然模拟了 <code>combineReducers</code> 的功能，但失去了 <code>combineReducers</code> 的检查对象变化的功能，因为现在的 default block 中会返回一个全新的对象。<br>有没有方法可以既保留 <code>combineReducers</code> 的全部功能，又能扩展它呢？<br>其实很简单，我们只要利用 <code>combineReducers</code> 返回的函数就可以了！<br>(感谢 liximomo 指出上面例子中的缺陷)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reCombineReducers</span>(<span class="params">reducers</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> fn = combineReducers(reducers);</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">      <span class="keyword">case</span> SP_ACTION:</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123; <span class="comment">/* do something */</span> &#125;);</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> fn(state, action);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>按照 Redux 的原则，不同的 reducer 应该相互独立的，它们之间不应该有任何依赖。<br>这个原则看着是很美好的，但在实际使用中还是会有一些例外的情况。<br>一个很简单的例子，也是我遇到过的例子，就是实现一个简单的表格 (其实我的情况复杂的多，需要实现类似 Excel 那样的操作，同时支持其他额外的功能)。<br>我们先来设计一下 <code>state</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// state</span></div><div class="line">&#123;</div><div class="line">  <span class="attr">rows</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">cells</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">data</span>: &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>rows</code>, <code>cells</code>, <code>data</code> 都会响应一些特定的 <code>action</code> (如 <code>CHANGE_ROW_PROPS</code>, <code>CHANGE_CELL_PROPS</code>, <code>CHANGE_DATA</code>)，做出相应的改变，这些都是我们所期望的。<br>然而，当出现一些特殊的 action (如 <code>GET_TABLE_SUCCESS</code>，表示成功从服务端获取数据) 的时候，灾难就出现了：<br>所有的 reducer 都需要监听 <code>GET_TABLE_SUCCESS</code> 这个 action，这意味着如果我们有 n 个 reducer 的话，我们就需要修改 n 个文件！<br>当我再加上 <code>UPDATE_TABLE_SUCCESS</code>，<code>REMOVE_TABLE_SUCCESS</code> 之类的 <code>action</code> 时，我要再修改 n 个文件！<br>这不合理啊，为什么我加一个简单的功能，需要修改这么多文件，最重要的是，这些修改都是非常类似！</p>
<p>这时候，我们就需要自定义 <code>combineReducers</code> 来解决我们的需求拉：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reCombineReducers</span>(<span class="params">reducers</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> fn = combineReducers(reducers);</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">      <span class="keyword">case</span> GET_TABLE_SUCCESS:</div><div class="line">      <span class="keyword">case</span> UPDATE_TABLE_SUCCESS:</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, action.payload.table);</div><div class="line">      <span class="keyword">case</span> REMOVE_TABLE_SUCCESS:</div><div class="line">        <span class="keyword">return</span> initState;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> fn(state, action);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> table = reCombineReducers(&#123;</div><div class="line">  sections,</div><div class="line">  suites,</div><div class="line">  rows,</div><div class="line">  cells,</div><div class="line">  toys,</div><div class="line">  data,</div><div class="line">  logics</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>怎么样，是不是比修改多个文件舒服很多？</p>
<p>(完)</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://redux.js.org/docs/api/combineReducers.html" target="_blank" rel="external">http://redux.js.org/docs/api/combineReducers.html</a><br><a href="https://github.com/reactjs/redux/blob/master/src/combineReducers.js" target="_blank" rel="external">https://github.com/reactjs/redux/blob/master/src/combineReducers.js</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Redux 中的 &lt;code&gt;combineReducers&lt;/code&gt; 能让我们很方便地把多个 reducers 组合起来，成为一个新的
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
      <category term="redux" scheme="http://scarletsky.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>用 GitLab CI 进行持续集成</title>
    <link href="http://scarletsky.github.io/2016/07/29/use-gitlab-ci-for-continuous-integration/"/>
    <id>http://scarletsky.github.io/2016/07/29/use-gitlab-ci-for-continuous-integration/</id>
    <published>2016-07-29T01:22:20.000Z</published>
    <updated>2016-07-30T06:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>从 GitLab 8.0 开始，GitLab CI 就已经集成在 GitLab 中，我们只要在项目中添加一个 <code>.gitlab-ci.yml</code> 文件，然后添加一个 Runner，即可进行持续集成。 而且随着 GitLab 的升级，GitLab CI 变得越来越强大，本文将介绍如何使用 GitLab CI 进行持续集成。</p>
<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><p>在介绍 GitLab CI 之前，我们先看看一些持续集成相关的概念。</p>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>一次 Pipeline 其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。<br>任何提交或者 Merge Request 的合并都可以触发 Pipeline，如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+------------------+           +----------------+</div><div class="line">|                  |  trigger  |                |</div><div class="line">|   Commit / MR    +----------&gt;+    Pipeline    |</div><div class="line">|                  |           |                |</div><div class="line">+------------------+           +----------------+</div></pre></td></tr></table></figure>
<h2 id="Stages"><a href="#Stages" class="headerlink" title="Stages"></a>Stages</h2><p>Stages 表示构建阶段，说白了就是上面提到的流程。<br>我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点：</p>
<ul>
<li>所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始</li>
<li>只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功</li>
<li>如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败</li>
</ul>
<p>因此，Stages 和 Pipeline 的关系就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+--------------------------------------------------------+</div><div class="line">|                                                        |</div><div class="line">|  Pipeline                                              |</div><div class="line">|                                                        |</div><div class="line">|  +-----------+     +------------+      +------------+  |</div><div class="line">|  |  Stage 1  |----&gt;|   Stage 2  |-----&gt;|   Stage 3  |  |</div><div class="line">|  +-----------+     +------------+      +------------+  |</div><div class="line">|                                                        |</div><div class="line">+--------------------------------------------------------+</div></pre></td></tr></table></figure>
<h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p>Jobs 表示构建工作，表示某个 Stage 里面执行的工作。<br>我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点：</p>
<ul>
<li>相同 Stage 中的 Jobs 会并行执行</li>
<li>相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功</li>
<li>如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败</li>
</ul>
<p>所以，Jobs 和 Stage 的关系图就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+------------------------------------------+</div><div class="line">|                                          |</div><div class="line">|  Stage 1                                 |</div><div class="line">|                                          |</div><div class="line">|  +---------+  +---------+  +---------+   |</div><div class="line">|  |  Job 1  |  |  Job 2  |  |  Job 3  |   |</div><div class="line">|  +---------+  +---------+  +---------+   |</div><div class="line">|                                          |</div><div class="line">+------------------------------------------+</div></pre></td></tr></table></figure>
<h1 id="GitLab-Runner"><a href="#GitLab-Runner" class="headerlink" title="GitLab Runner"></a>GitLab Runner</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>理解了上面的基本概念之后，有没有觉得少了些什么东西 —— 由谁来执行这些构建任务呢？<br>答案就是 GitLab Runner 了！</p>
<p>想问为什么不是 GitLab CI 来运行那些构建任务？<br>一般来说，构建任务都会占用很多的系统资源 (譬如编译代码)，而 GitLab CI 又是 GitLab 的一部分，如果由 GitLab CI 来运行构建任务的话，在执行构建任务的时候，GitLab 的性能会大幅下降。</p>
<p>GitLab CI 最大的作用是管理各个项目的构建状态，因此，运行构建任务这种浪费资源的事情就交给 GitLab Runner 来做拉！<br>因为 GitLab Runner 可以安装到不同的机器上，所以在构建任务运行期间并不会影响到 GitLab 的性能~</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 GitLab Runner 太简单了，按照着 <a href="https://gitlab.com/gitlab-org/gitlab-ci-multi-runner" target="_blank" rel="external">官方文档</a> 的教程来就好拉！<br>下面是 Debian/Ubuntu/CentOS 的安装方法，其他系统去参考官方文档：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># For Debian/Ubuntu</span></div><div class="line">$ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.deb.sh | sudo bash</div><div class="line">$ sudo apt-get install gitlab-ci-multi-runner</div><div class="line"></div><div class="line"><span class="comment"># For CentOS</span></div><div class="line">$ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash</div><div class="line">$ sudo yum install gitlab-ci-multi-runner</div></pre></td></tr></table></figure>
<h2 id="注册-Runner"><a href="#注册-Runner" class="headerlink" title="注册 Runner"></a>注册 Runner</h2><p>安装好 GitLab Runner 之后，我们只要启动 Runner 然后和 CI 绑定就可以了：</p>
<ul>
<li>打开你 GitLab 中的项目页面，在项目设置中找到 runners</li>
<li>运行 <code>sudo gitlab-ci-multi-runner register</code></li>
<li>输入 CI URL</li>
<li>输入 Token</li>
<li>输入 Runner 的名字</li>
<li>选择 Runner 的类型，简单起见还是选 Shell 吧</li>
<li>完成</li>
</ul>
<p>当注册好 Runner 之后，可以用 <code>sudo gitlab-ci-multi-runner list</code> 命令来查看各个 Runner 的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ sudo gitlab-runner list</div><div class="line">Listing configured runners          ConfigFile=/etc/gitlab-runner/config.toml</div><div class="line">my-runner                           Executor=shell Token=<span class="built_in">cd</span>1<span class="built_in">cd</span>7cf243afb47094677855aacd3 URL=http://mygitlab.com/ci</div></pre></td></tr></table></figure>
<h1 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>配置好 Runner 之后，我们要做的事情就是在项目根目录中添加 <code>.gitlab-ci.yml</code> 文件了。<br>当我们添加了 <code>.gitlab-ci.yml</code> 文件后，每次提交代码或者合并 MR 都会自动运行构建任务了。</p>
<p>还记得 Pipeline 是怎么触发的吗？Pipeline 也是通过提交代码或者合并 MR 来触发的！<br>那么 Pipeline 和 <code>.gitlab-ci.yml</code> 有什么关系呢？<br>其实 <code>.gitlab-ci.yml</code> 就是在定义 Pipeline 而已拉！</p>
<h2 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h2><p>我们先来看看 <code>.gitlab-ci.yml</code> 是怎么写的：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 定义 stages</span></div><div class="line"><span class="attr">stages:</span></div><div class="line"><span class="bullet">  -</span> build</div><div class="line"><span class="bullet">  -</span> test</div><div class="line"></div><div class="line"><span class="comment"># 定义 job</span></div><div class="line"><span class="attr">job1:</span></div><div class="line"><span class="attr">  stage:</span> test</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> echo <span class="string">"I am job1"</span></div><div class="line"><span class="bullet">    -</span> echo <span class="string">"I am in test stage"</span></div><div class="line"></div><div class="line"><span class="comment"># 定义 job</span></div><div class="line"><span class="attr">job2:</span></div><div class="line"><span class="attr">  stage:</span> build</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> echo <span class="string">"I am job2"</span></div><div class="line"><span class="bullet">    -</span> echo <span class="string">"I am in build stage"</span></div></pre></td></tr></table></figure>
<p>写起来很简单吧！用 <code>stages</code> 关键字来定义 Pipeline 中的各个构建阶段，然后用一些非关键字来定义 jobs。<br>每个 job 中可以可以再用 <code>stage</code> 关键字来指定该 job 对应哪个 stage。<br>job 里面的 <code>script</code> 关键字是最关键的地方了，也是每个 job 中必须要包含的，它表示每个 job 要执行的命令。</p>
<p>回想一下我们之前提到的 Stages 和 Jobs 的关系，然后猜猜上面例子的运行结果？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">I am job2</div><div class="line">I am in build stage</div><div class="line">I am job1</div><div class="line">I am in test stage</div></pre></td></tr></table></figure>
<p>根据我们在 <code>stages</code> 中的定义，<code>build</code> 阶段要在 <code>test</code> 阶段之前运行，所以 <code>stage:build</code> 的 jobs 会先运行，之后才会运行 <code>stage:test</code> 的 jobs。</p>
<h2 id="常用的关键字"><a href="#常用的关键字" class="headerlink" title="常用的关键字"></a>常用的关键字</h2><p>下面介绍一些常用的关键字，想要更加详尽的内容请前往 <a href="http://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="external">官方文档</a></p>
<h3 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h3><p>定义 Stages，默认有三个 Stages，分别是 <code>build</code>, <code>test</code>, <code>deploy</code>。</p>
<h3 id="types"><a href="#types" class="headerlink" title="types"></a>types</h3><p><code>stages</code> 的别名。</p>
<h3 id="before-script"><a href="#before-script" class="headerlink" title="before_script"></a>before_script</h3><p>定义任何 Jobs 运行前都会执行的命令。</p>
<h3 id="after-script"><a href="#after-script" class="headerlink" title="after_script"></a>after_script</h3><blockquote>
<p>要求 GitLab 8.7+ 和 GitLab Runner 1.2+</p>
</blockquote>
<p>定义任何 Jobs 运行完后都会执行的命令。</p>
<h3 id="variables-amp-amp-Job-variables"><a href="#variables-amp-amp-Job-variables" class="headerlink" title="variables &amp;&amp; Job.variables"></a>variables &amp;&amp; Job.variables</h3><blockquote>
<p>要求 GitLab Runner 0.5.0+</p>
</blockquote>
<p>定义环境变量。<br>如果定义了 Job 级别的环境变量的话，该 Job 会优先使用 Job 级别的环境变量。</p>
<h3 id="cache-amp-amp-Job-cache"><a href="#cache-amp-amp-Job-cache" class="headerlink" title="cache &amp;&amp; Job.cache"></a>cache &amp;&amp; Job.cache</h3><blockquote>
<p>要求 GitLab Runner 0.7.0+</p>
</blockquote>
<p>定义需要缓存的文件。<br>每个 Job 开始的时候，Runner 都会删掉 <code>.gitignore</code> 里面的文件。<br>如果有些文件 (如 <code>node_modules/</code>) 需要多个 Jobs 共用的话，我们只能让每个 Job 都先执行一遍 <code>npm install</code>。<br>这样很不方便，因此我们需要对这些文件进行缓存。缓存了的文件除了可以跨 Jobs 使用外，还可以跨 Pipeline 使用。</p>
<p>具体用法请查看 <a href="http://docs.gitlab.com/ce/ci/yaml/README.html#cache" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="Job-script"><a href="#Job-script" class="headerlink" title="Job.script"></a>Job.script</h3><p>定义 Job 要运行的命令，必填项。</p>
<h3 id="Job-stage"><a href="#Job-stage" class="headerlink" title="Job.stage"></a>Job.stage</h3><p>定义 Job 的 stage，默认为 <code>test</code>。</p>
<h3 id="Job-artifacts"><a href="#Job-artifacts" class="headerlink" title="Job.artifacts"></a>Job.artifacts</h3><p>定义 Job 中生成的附件。<br>当该 Job 运行成功后，生成的文件可以作为附件 (如生成的二进制文件) 保留下来，打包发送到 GitLab，之后我们可以在 GitLab 的项目页面下下载该附件。<br>注意，不要把 <code>artifacts</code> 和 <code>cache</code> 混淆了。</p>
<h2 id="实用例子"><a href="#实用例子" class="headerlink" title="实用例子"></a>实用例子</h2><p>下面给出一个我自己在用的例子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">stages:</span></div><div class="line"><span class="bullet">  -</span> install_deps</div><div class="line"><span class="bullet">  -</span> test</div><div class="line"><span class="bullet">  -</span> build</div><div class="line"><span class="bullet">  -</span> deploy_test</div><div class="line"><span class="bullet">  -</span> deploy_production</div><div class="line"></div><div class="line"><span class="attr">cache:</span></div><div class="line"><span class="attr">  key:</span> $&#123;CI_BUILD_REF_NAME&#125;</div><div class="line"><span class="attr">  paths:</span></div><div class="line"><span class="bullet">    -</span> node_modules/</div><div class="line"><span class="bullet">    -</span> dist/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 安装依赖</span></div><div class="line"><span class="attr">install_deps:</span></div><div class="line"><span class="attr">  stage:</span> install_deps</div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">    -</span> develop</div><div class="line"><span class="bullet">    -</span> master</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> npm install</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 运行测试用例</span></div><div class="line"><span class="attr">test:</span></div><div class="line"><span class="attr">  stage:</span> test</div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">    -</span> develop</div><div class="line"><span class="bullet">    -</span> master</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> npm run test</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 编译</span></div><div class="line"><span class="attr">build:</span></div><div class="line"><span class="attr">  stage:</span> build</div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">    -</span> develop</div><div class="line"><span class="bullet">    -</span> master</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> npm run clean</div><div class="line"><span class="bullet">    -</span> npm run build:client</div><div class="line"><span class="bullet">    -</span> npm run build:server</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 部署测试服务器</span></div><div class="line"><span class="attr">deploy_test:</span></div><div class="line"><span class="attr">  stage:</span> deploy_test</div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">    -</span> develop</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> pm2 delete app || <span class="literal">true</span></div><div class="line"><span class="bullet">    -</span> pm2 start app.js --name app</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 部署生产服务器</span></div><div class="line"><span class="attr">deploy_production:</span></div><div class="line"><span class="attr">  stage:</span> deploy_production</div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">    -</span> master</div><div class="line"><span class="attr">  script:</span></div><div class="line"><span class="bullet">    -</span> bash scripts/deploy/deploy.sh</div></pre></td></tr></table></figure>
<p>上面的配置把一次 Pipeline 分成五个阶段：</p>
<ul>
<li>安装依赖(<code>install_deps</code>)</li>
<li>运行测试(<code>test</code>)</li>
<li>编译(<code>build</code>)</li>
<li>部署测试服务器(<code>deploy_test</code>)</li>
<li>部署生产服务器(<code>deploy_production</code>)</li>
</ul>
<p>设置 <code>Job.only</code> 后，只有当 develop 分支和 master 分支有提交的时候才会触发相关的 Jobs。<br>注意，我这里用 GitLab Runner 所在的服务器作为测试服务器。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://about.gitlab.com/gitlab-ci/" target="_blank" rel="external">https://about.gitlab.com/gitlab-ci/</a><br><a href="http://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="external">http://docs.gitlab.com/ce/ci/yaml/README.html</a><br><a href="http://docs.gitlab.com/ce/ci/variables/README.html" target="_blank" rel="external">http://docs.gitlab.com/ce/ci/variables/README.html</a><br><a href="https://gitlab.com/gitlab-org/gitlab-ci-multi-runner" target="_blank" rel="external">https://gitlab.com/gitlab-org/gitlab-ci-multi-runner</a><br><a href="https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/issues/1232" target="_blank" rel="external">https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/issues/1232</a><br><a href="http://stackbox.cn/2016-02-gitlab-ci-conf/" target="_blank" rel="external">http://stackbox.cn/2016-02-gitlab-ci-conf/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;从 GitLab 8.0 开始，GitLab CI 就已经集成在 GitLab 中，我们只要在项目中添加一个 &lt;code&gt;.gitlab-c
    
    </summary>
    
    
      <category term="ci" scheme="http://scarletsky.github.io/tags/ci/"/>
    
      <category term="gitlab-ci" scheme="http://scarletsky.github.io/tags/gitlab-ci/"/>
    
  </entry>
  
  <entry>
    <title>Non-deterministic value and List Monad in Haskell</title>
    <link href="http://scarletsky.github.io/2016/07/16/non-determinism-value-and-list-monad-in-haskell/"/>
    <id>http://scarletsky.github.io/2016/07/16/non-determinism-value-and-list-monad-in-haskell/</id>
    <published>2016-07-16T08:01:39.000Z</published>
    <updated>2016-07-16T16:11:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>看 《Learn you a haskell for a great good》 这本书的过程中，有时候会看到 <strong>non-determinism</strong> 这个词，虽然具体不知道什么意思，但不影响阅读，所以就没深究。<br>最近看到 List Monad 部分的时候，这个词的出现频率比以前高得多。这时候我才留意到，<strong>non-determinism</strong> 之前也是在 List 相关的地方出现的。<br>那么，<strong>non-determinism</strong> 到底指的是什么呢？</p>
<h2 id="deterministic-value-与-non-deterministic-value"><a href="#deterministic-value-与-non-deterministic-value" class="headerlink" title="deterministic value 与 non-deterministic value"></a>deterministic value 与 non-deterministic value</h2><p>在理解 <strong>non-deterministic value</strong> 之前，我们先看看什么是 <strong>deterministic value</strong>。</p>
<p>从字面意思推测，<strong>deterministic value</strong> 是确定的值，那确定的值到底是什么呢？书中有这么一段话：</p>
<blockquote>
<p>A value like 5 is deterministic. It has only one result and we know exactly what it is. On the other hand, a value like [3,8,9] contains several results, so we can view it as one value that is actually many values at the same time.</p>
</blockquote>
<p>像 5 这种只表示一种结果的值，它就是确定的值。<br>像 [3,8,9] 那样，它包含了多个值，我们可以把它看成是用一个值来表示多个结果，例如它可以表示 3，也可以表示 8，也可以表示 9，因此它是非确定值。</p>
<p><strong>deterministic value</strong> 和 <strong>non-deterministic value</strong> 的区别就在这里。</p>
<p>那么 <strong>non-deterministic value</strong> 到底有什么用呢？<br>我们知道了它可以表示多个结果，那么在动态计算的时候就很方便了，先看看下面这个简单的例子：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">do</span></div><div class="line">  x &lt;- [<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">  y &lt;- [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</div><div class="line">  return (x + y)</div></pre></td></tr></table></figure>
<p>因为 <code>x</code> 可以 1 或者 2， <code>y</code> 可以表示 4 或者 5 或者 6，所以 <code>x+y</code> 就可以表示出 <code>1+4</code>, <code>1+5</code>, <code>1+6</code>, <code>2+4</code>, <code>2+5</code>, <code>2+6</code> 这么多结果了！</p>
<h2 id="List-Monad"><a href="#List-Monad" class="headerlink" title="List Monad"></a>List Monad</h2><p>理解了 <strong>non-deterministic value</strong> 之后，我们再来看看 List Monad。<br>我们知道，不同的 Monad 带有不同的 context，如 Maybe Monad 带有可能失败的 context，那 List Monad 带有怎样的 context 呢？<br>答案就是 <strong>non-determinism</strong>。</p>
<p>先看看 List Monad 的定义：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> [] <span class="keyword">where</span></span></div><div class="line">  return x = [x]</div><div class="line">  xs &gt;&gt;= f = concat (map f xs)</div><div class="line">  fail _ []</div></pre></td></tr></table></figure>
<p>我们主要看看 <code>&gt;&gt;=</code> 的实现，它把 f 应用到 List 中的每个元素中，然后再把结果扁平化而已。<br>虽然看起来很简单，但用起来很强大：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 1</span></div><div class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] &gt;&gt;= \x -&gt; [x,-x]  </div><div class="line">[<span class="number">3</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-4</span>,<span class="number">5</span>,<span class="number">-5</span>]</div><div class="line"></div><div class="line"><span class="comment">-- 2</span></div><div class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &gt;&gt;= \x -&gt; [x+<span class="number">1</span>] &gt;&gt;= \y -&gt; [y*<span class="number">2</span>]</div><div class="line">[<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]</div><div class="line"></div><div class="line"><span class="comment">-- 3</span></div><div class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>] &gt;&gt;= \n -&gt; ['a','b'] &gt;&gt;= \ch -&gt; return (n,ch)</div><div class="line">[(<span class="number">1</span>,'a'),(<span class="number">1</span>,'b'),(<span class="number">2</span>,'a'),(<span class="number">2</span>,'b')]</div><div class="line"></div><div class="line"><span class="comment">-- 4</span></div><div class="line"><span class="title">ghci</span>&gt; [ (n, ch) | n &lt;- [<span class="number">1</span>,<span class="number">2</span>], ch &lt;- ['a', 'b'] ]</div><div class="line">[(<span class="number">1</span>,'a'),(<span class="number">1</span>,'b'),(<span class="number">2</span>,'a'),(<span class="number">2</span>,'b')]</div></pre></td></tr></table></figure>
<p>留意最后两个例子，事实上列表推导 (List Comprehension) 只是 List Monad 的一种语法糖而已。</p>
<p>最后提一下一个很炫的技巧：用 <code>filterM</code> 来生成一个列表的幂集 (Power Set)，即该列表中的所有子列表，如：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- [1,2,3] 的幂集就是</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </div><div class="line">[<span class="number">1</span>,<span class="number">2</span>]  </div><div class="line">[<span class="number">1</span>,<span class="number">3</span>]  </div><div class="line">[<span class="number">1</span>]  </div><div class="line">[<span class="number">2</span>,<span class="number">3</span>]  </div><div class="line">[<span class="number">2</span>]  </div><div class="line">[<span class="number">3</span>]  </div><div class="line">[]</div></pre></td></tr></table></figure>
<p>利用 <code>filterM</code> 和 List Monad 可以非常轻松地实现幂集：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> Control.Monad</div><div class="line"></div><div class="line"><span class="title">powerset</span> :: [a] -&gt; [[a]]</div><div class="line"><span class="title">powerset</span> xs = filterM (\x -&gt; [ <span class="type">True</span>, <span class="type">False</span> ]) xs</div><div class="line"></div><div class="line"><span class="comment">-- in ghci</span></div><div class="line"><span class="title">ghci</span>&gt; powerset [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>],[<span class="number">3</span>],[]]</div></pre></td></tr></table></figure>
<p>很神奇吧！想知道为什么的话，去看看下面的链接吧：<br><a href="http://stackoverflow.com/questions/28872396/haskells-filterm-with-filterm-x-true-false-1-2-3" target="_blank" rel="external">http://stackoverflow.com/questions/28872396/haskells-filterm-with-filterm-x-true-false-1-2-3</a> </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://stackoverflow.com/questions/29886852/why-is-the-following-haskell-code-non-deterministic" target="_blank" rel="external">http://stackoverflow.com/questions/29886852/why-is-the-following-haskell-code-non-deterministic</a><br><a href="http://stackoverflow.com/questions/20638893/how-can-non-determinism-be-modeled-with-a-list-monad" target="_blank" rel="external">http://stackoverflow.com/questions/20638893/how-can-non-determinism-be-modeled-with-a-list-monad</a><br><a href="http://learnyoua.haskell.sg/content/zh-cn/ch12/a-fistful-of-monads.html" target="_blank" rel="external">http://learnyoua.haskell.sg/content/zh-cn/ch12/a-fistful-of-monads.html</a><br><a href="http://learnyoua.haskell.sg/content/zh-cn/ch13/for-a-few-monads-more.html" target="_blank" rel="external">http://learnyoua.haskell.sg/content/zh-cn/ch13/for-a-few-monads-more.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;看 《Learn you a haskell for a great good》 这本书的过程中，有时候会看到 &lt;strong&gt;non-de
    
    </summary>
    
      <category term="haskell" scheme="http://scarletsky.github.io/categories/haskell/"/>
    
    
      <category term="haskell" scheme="http://scarletsky.github.io/tags/haskell/"/>
    
  </entry>
  
  <entry>
    <title>如何用 JavaScript 下载文件</title>
    <link href="http://scarletsky.github.io/2016/07/03/download-file-using-javascript/"/>
    <id>http://scarletsky.github.io/2016/07/03/download-file-using-javascript/</id>
    <published>2016-07-03T10:43:41.000Z</published>
    <updated>2016-07-03T10:43:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们知道，下载文件是一个非常常见的需求，但由于浏览器的安全策略的限制，我们通常只能通过一个额外的页面，访问某个文件的 url 来实现下载功能，但是这种用户体验非常不好。<br>幸好，HTML 5 里面为 <code>&lt;a&gt;</code> 标签添加了一个 <code>download</code> 的属性，我们可以轻易的利用它来实现下载功能，再也不需要用以前的笨办法了。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们先看看 <code>download</code> 的使用方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://somehost/somefile.zip"</span> <span class="attr">download</span>=<span class="string">"filename.zip"</span>&gt;</span>Download file<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>看看上面的代码，只要为 <code>&lt;a&gt;</code> 标签添加 <code>download</code> 属性，我们点击这个链接的时候就会自动下载文件了~<br>顺便说下，<code>download</code> 的属性值是可选的，它用来指定下载文件的文件名。像上面的例子中，我们下载到本地的文件名就会是 filename.zip 拉，如果不指定的话，它就会是 somefile.zip 这个名字拉！</p>
<p>看到这里，你可能会说，坑爹啊，这明明是用 HTML 5 的新特性来实现下载文件嘛，说好的用 JavaScript 下载文件呢？</p>
<p>事实上，用 JavaScript 来下载文件也是利用这一特性来实现的，我们的 JavaScript 代码不外乎就是：</p>
<ul>
<li>用 JavaScript 创建一个隐藏的 <code>&lt;a&gt;</code> 标签</li>
<li>设置它的 <code>href</code> 属性</li>
<li>设置它的 <code>download</code> 属性</li>
<li>用 JavaScript 来触发这个它的 <code>click</code> 事件</li>
</ul>
<p>翻译成 JavaScript 代码就是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</div><div class="line"><span class="keyword">var</span> filename = <span class="string">'what-you-want.txt'</span>;</div><div class="line">a.href = url;</div><div class="line">a.download = filename;</div><div class="line">a.click();</div><div class="line"><span class="built_in">window</span>.URL.revokeObjectURL(url);</div></pre></td></tr></table></figure>
<p>好拉，是不是看到有个陌生的东东呢？</p>
<h2 id="window-URL"><a href="#window-URL" class="headerlink" title="window.URL"></a>window.URL</h2><p><code>window.URL</code> 里面有两个方法： </p>
<ul>
<li><code>createObjectURL</code> 用 blob 对象来创建一个 object URL(它是一个 <code>DOMString</code>)，我们可以用这个 object URL 来表示某个 blob 对象，这个 object URL 可以用在 <code>href</code> 和 <code>src</code> 之类的属性上。</li>
<li><code>revokeObjectURL</code> 释放由 <code>createObjectURL</code> 创建的 object URL，当该 object URL 不需要的时候，我们要主动调用这个方法来获取最佳性能和内存使用。</li>
</ul>
<p>知道了这两个方法之后，我们再回去看看上面的例子就很容易理解了吧！只是用 blob 对象来创建一条 URL，然后让 <code>&lt;a&gt;</code> 标签引用该 URL，然后触发个点击事件，就可以下载文件了！</p>
<p>那么问题来了，blob 对象哪里来？</p>
<h2 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h2><p>Blob 全称是 Binary large object，它表示一个类文件对象，可以用它来表示一个文件。根据 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="external">MDN</a> 上面的说法，<code>File API</code> 也是基于 blob 来实现的。</p>
<p>由于本文的主题是讲 JavaScript 下载文件，那我们构建 blob 的方式就是通过服务器返回的文件来创建 blob 拉！<br>而最简单的方式就是用 <code>fetch API</code> 了，我们可以整合上面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">fetch(<span class="string">'http://somehost/somefile.zip'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.blob().then(<span class="function"><span class="params">blob</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line">    <span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</div><div class="line">    <span class="keyword">var</span> filename = <span class="string">'myfile.zip'</span>;</div><div class="line">    a.href = url;</div><div class="line">    a.download = filename;</div><div class="line">    a.click();</div><div class="line">    <span class="built_in">window</span>.URL.revokeObjectURL(url);</div><div class="line">&#125;))</div></pre></td></tr></table></figure>
<p>很简单对吧！</p>
<p>你可能会问，何必这么麻烦呢？直接写成下面这样不就好了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://somehost/somefile.zip"</span> <span class="attr">download</span>=<span class="string">"myfile.zip"</span>&gt;</span>Download file<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>嗯，对于这种写法，我只能说，你做的太正确了！如果你要下载的是已经存在服务器上面的静态文件的话，那么写成这样是最方便的。浏览器会帮你处理整个下载过程，不需要你干涉。如果你用 blob 的方式来下载文件的话，会有下面这些限制的：</p>
<h3 id="限制一：不同浏览器对-blob-对象有不同的限制"><a href="#限制一：不同浏览器对-blob-对象有不同的限制" class="headerlink" title="限制一：不同浏览器对 blob 对象有不同的限制"></a>限制一：不同浏览器对 blob 对象有不同的限制</h3><p>具体看看下面这个表格（出自 <a href="https://github.com/eligrey/FileSaver.js#supported-browsers" target="_blank" rel="external">FileSaver.js</a>）：</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Constructs as</th>
<th>Filenames</th>
<th>Max Blob Size</th>
<th>Dependencies</th>
</tr>
</thead>
<tbody>
<tr>
<td>Firefox 20+</td>
<td>Blob</td>
<td>Yes</td>
<td>800 MiB</td>
<td>None</td>
</tr>
<tr>
<td>Firefox &lt; 20</td>
<td>data: URI</td>
<td>No</td>
<td>n/a</td>
<td><a href="https://github.com/eligrey/Blob.js" target="_blank" rel="external">Blob.js</a></td>
</tr>
<tr>
<td>Chrome</td>
<td>Blob</td>
<td>Yes</td>
<td>500 MiB</td>
<td>None</td>
</tr>
<tr>
<td>Chrome for Android</td>
<td>Blob</td>
<td>Yes</td>
<td>500 MiB</td>
<td>None</td>
</tr>
<tr>
<td>Edge</td>
<td>Blob</td>
<td>Yes</td>
<td>?</td>
<td>None</td>
</tr>
<tr>
<td>IE 10+</td>
<td>Blob</td>
<td>Yes</td>
<td>600 MiB</td>
<td>None</td>
</tr>
<tr>
<td>Opera 15+</td>
<td>Blob</td>
<td>Yes</td>
<td>500 MiB</td>
<td>None</td>
</tr>
<tr>
<td>Opera &lt; 15</td>
<td>data: URI</td>
<td>No</td>
<td>n/a</td>
<td><a href="https://github.com/eligrey/Blob.js" target="_blank" rel="external">Blob.js</a></td>
</tr>
<tr>
<td>Safari 6.1+*</td>
<td>Blob</td>
<td>No</td>
<td>?</td>
<td>None</td>
</tr>
<tr>
<td>Safari &lt; 6</td>
<td>data: URI</td>
<td>No</td>
<td>n/a</td>
<td><a href="https://github.com/eligrey/Blob.js" target="_blank" rel="external">Blob.js</a></td>
</tr>
</tbody>
</table>
<h3 id="限制二：构建完-blob-对象后才会转换成文件"><a href="#限制二：构建完-blob-对象后才会转换成文件" class="headerlink" title="限制二：构建完 blob 对象后才会转换成文件"></a>限制二：构建完 blob 对象后才会转换成文件</h3><p>这一点限制对小文件(几十kb)可能没什么影响，但对稍微大一点的文件影响就很大了。试想，用户要下载一个 100mb 的文件，如果他点击了下载按钮之后没看到下载提示的话，他肯定会继续按，等他按了几次之后还没看到下载提示时，他就会抱怨我们的网站，然后离开了。</p>
<p>然而事实上下载的的确确发生了，只是要等到下载完文件之后才能构建 blob 对象，再转化成文件。而且，用户再触发多几次下载就会造成一些资源上的浪费。</p>
<p>因此，如果是要下载大文件的话，还是推荐直接创建一个 <code>&lt;a&gt;</code> 标签拉~<br>写 html 也好，写 JavaScript 动态创建也好，用自己喜欢的方式去创建就好了。</p>
<h2 id="为什么要用-JavaScript-下载文件"><a href="#为什么要用-JavaScript-下载文件" class="headerlink" title="为什么要用 JavaScript 下载文件"></a>为什么要用 JavaScript 下载文件</h2><p>好拉，说了半天，其实我们一直说的都是：「不要用 JavaScript 下载文件拉，限制多多，又不好用，直接用 html 就好拉，简单方便又快捷」这个论调。<br>事实上也确实如此，但有些时候我们确实需要通过 JavaScript 来做一些<strong>预</strong>处理。</p>
<h3 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h3><p>有些时候，我们需要对下载做一些限制，最常见的就是权限校验了，如检查该用户是否有下载的权限，是否有高速下载的权限等等。这时候，我们可以利用 JavaScript 做一些预处理。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">fetch(<span class="string">'http://somehost/check-permission'</span>, options).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (res.code === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line">        <span class="keyword">var</span> url = res.data.url;</div><div class="line">        <span class="keyword">var</span> filename = <span class="string">'myfile.zip'</span>;</div><div class="line">        a.href = url;</div><div class="line">        a.download = filename;</div><div class="line">        a.click();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        alert(<span class="string">'You have no permission to download the file!'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这个例子里面，我们没有用 blob 来构建 URL，而是通过后端服务器来计算出用户的下载链接，然后再利用之前提到的动态创建 <code>&lt;a&gt;</code> 标签的方式来实现下载，很简单吧！</p>
<h3 id="动态文件"><a href="#动态文件" class="headerlink" title="动态文件"></a>动态文件</h3><p>动态生成文件然后返回给客户端也是一个很常见的需求，譬如我们有时候需要做导出数据的功能，把数据库中的某些数据导出到 Excel 中，然后再返回客户端。<br>这时候我们就不能简单的指定 <code>href</code> 属性，因为对应的 URL 并不存在。<br>我们只能通过 JavaScript 对服务器发出一个请求，通知它去生成某个文件，然后把对应的 URL 返回给客户端。<br>有没有感觉这个过程和上面「权限校验」一节很像？肯定拉，因为我们只是对 URL 做了一些预处理而已嘛~</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>由于 <code>download</code> 属性是 HTML 5 的新特性，因此它不支持旧版本的浏览器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTML 5 新的 <code>download</code> 特性真的很好用，结合 JavaScript 的动态能力我们可以很方便的做出复杂的下载功能~</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/eligrey/FileSaver.js/blob/master/FileSaver.js" target="_blank" rel="external">https://github.com/eligrey/FileSaver.js/blob/master/FileSaver.js</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/API/Blob</a><br><a href="http://stackoverflow.com/questions/19327749/javascript-blob-filename-without-link" target="_blank" rel="external">http://stackoverflow.com/questions/19327749/javascript-blob-filename-without-link</a><br><a href="http://stackoverflow.com/questions/24501358/how-to-set-a-header-for-a-http-get-request-and-trigger-file-download" target="_blank" rel="external">http://stackoverflow.com/questions/24501358/how-to-set-a-header-for-a-http-get-request-and-trigger-file-download</a><br><a href="http://blog.bguiz.com/2014/07/03/file-download-with-http-request-header/" target="_blank" rel="external">http://blog.bguiz.com/2014/07/03/file-download-with-http-request-header/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;我们知道，下载文件是一个非常常见的需求，但由于浏览器的安全策略的限制，我们通常只能通过一个额外的页面，访问某个文件的 url 来实现下载功能
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>「译」Node.js Streams 基础</title>
    <link href="http://scarletsky.github.io/2016/07/01/basics-node-js-streams/"/>
    <id>http://scarletsky.github.io/2016/07/01/basics-node-js-streams/</id>
    <published>2016-07-01T05:45:12.000Z</published>
    <updated>2016-07-02T13:51:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js 天生异步和事件驱动，非常适合处理 I/O 相关的任务。如果你在处理应用中 I/O 相关的操作，你可以利用 Node.js 中的流(stream)。因此，我们先具体看看流，理解一下它们是怎么简化 I/O 操作的吧。</p>
<h2 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h2><p>流是 unix 管道，让你可以很容易地从数据源读取数据，然后流向另一个目的地。<br>简单来说，流不是什么特别的东西，它只是一个实现了一些方法的 <code>EventEmitter</code>。根据它实现的方法，流可以变成可读流(Readable)，可写流(Writable)，或者双向流(Duplex，同时可读可写)。<br>可读流能让你从一个数据源读取数据，而可写流则可以让你往目的地写入数据。</p>
<p>如果你已经用过 Node.js，你很可能已经遇到过流了。<br>例如，在一个 Node.js 的 HTTP 服务器里面，<code>request</code> 是一个可读流，<code>response</code> 是一个可写流。<br>你也可能用过 <code>fs</code> 模块，它能帮你处理可读可写流。</p>
<p>现在让你学一些基础，理解不同类型的流。本文会讨论可读流和可写流，双向流超出了本文的讨论范围，我们不作讨论。</p>
<h2 id="可读流-Readable-Streams"><a href="#可读流-Readable-Streams" class="headerlink" title="可读流 (Readable Streams)"></a>可读流 (Readable Streams)</h2><p>我们可以用可读流从一个数据源中读取数据，这个数据源可以是任何东西，例如系统中的一个文件，内存中的 buffer，甚至是其他流。因为流是 <code>EventEmitter</code>，它们会用各种事件发送数据。我们会利用这些事件来让流工作。</p>
<h3 id="从流中读取数据"><a href="#从流中读取数据" class="headerlink" title="从流中读取数据"></a>从流中读取数据</h3><p>从流中读取数据最好的方式是监听 <code>data</code> 事件，添加一个回调函数。当有数据流过来的时候，可读流会发送 <code>data</code> 事件，回调函数就会触发。看看下面的代码片段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file.txt'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> readableStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">  data += chunk;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>fs.createReadStream</code> 会给你一个可读流。<br>最开始的时候，这个流不是流动态的。当你添加了 <code>data</code> 的事件监听器，加上一个回调函数时，它才会变成流动态的。在这之后，它就会读取一小块数据，然后传到你的回调函数里面。<br>流的实现者决定了 <code>data</code> 事件的触发频率，例如 HTTP request 会在读取到几 KB 数据的时候触发 <code>data</code> 事件。 当你从一个文件中读取数据的时候，你可能会决定当一行被读完的时候就触发 <code>data</code> 事件。</p>
<p>当没有数据可读的时候 (读到文件尾部时)，流就会发送 <code>end</code> 事件。在上面的例子中，我们监听了这个事件，当读完文件的时候，就把数据打印出来。</p>
<p>还有另一种读取流的方式，你只要在读到文件尾部前不断调用流实例中的 <code>read()</code> 方法就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file.txt'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line"><span class="keyword">var</span> chunk;</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">while</span> ((chunk = readableStream.read()) != <span class="literal">null</span>) &#123;</div><div class="line">    data += chunk;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>read()</code> 方法会从内部 buffer 中读取数据，当没有数据可读的时候，它会返回 <code>null</code>。<br>因此，在 while 循环中我们检查 <code>read()</code> 是不是返回 <code>null</code>，当它返回 <code>null</code> 的时候，就终止循环。<br>需要注意的是，当我们可以从流中读取数据的时候，<code>readable</code> 事件就会触发。</p>
<h3 id="设置编码"><a href="#设置编码" class="headerlink" title="设置编码"></a>设置编码</h3><p>默认情况下，你从流中读取到的是 <code>Buffer</code> 对象。如果你要读取的是字符串的话，这并不适合你。因此，你可以像下面的例子那样通过调用 <code>Readable.setEncoding()</code> 来设置流的编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file.txt'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line"></div><div class="line">readableStream.setEncoding(<span class="string">'utf8'</span>);</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">  data += chunk;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的例子中，我们把流的编码设置成 <code>utf8</code>，数据就会被解析成 <code>utf8</code>，回调函数中的 <code>chunk</code> 就会是字符串了。</p>
<h3 id="管道-Piping"><a href="#管道-Piping" class="headerlink" title="管道 (Piping)"></a>管道 (Piping)</h3><p>管道是一个很棒的机制，你不需要自己管理流的状态就可以从数据源中读取数据，然后写入到目的地中。我们先看看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file1.txt'</span>);</div><div class="line"><span class="keyword">var</span> writableStream = fs.createWriteStream(<span class="string">'file2.txt'</span>);</div><div class="line"></div><div class="line">readableStream.pipe(writableStream);</div></pre></td></tr></table></figure>
<p>上面的例子利用 <code>pipe()</code> 方法把 file1 的内容写到 file2 中。因为 <code>pipe()</code> 会帮你管理数据流，你不需要担心数据流的速度。这让 <code>pipe()</code> 变得非常简洁易用。<br>需要注意的是，<code>pipe()</code> 会返回目的地的流，因此你可以很轻易让多个流链接起来！</p>
<h3 id="链接-Chaining"><a href="#链接-Chaining" class="headerlink" title="链接 (Chaining)"></a>链接 (Chaining)</h3><p>假设有一个归档文件，你想要解压它。有很多方式可以完成这个任务。但最简洁的方式是利用管道和链接：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</div><div class="line"></div><div class="line">fs.createReadStream(<span class="string">'input.txt.gz'</span>)</div><div class="line">  .pipe(zlib.createGunzip())</div><div class="line">  .pipe(fs.createWriteStream(<span class="string">'output.txt'</span>));</div></pre></td></tr></table></figure>
<p>首先，我们通过 <code>input.txt.gz</code> 创建了一个可读流，然后让它流向 <code>zlib.createGunzip()</code> 流，它会解压内容。最后，我们添加一个可写流把解压后的内容写到另一个文件中。</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>我们已经讨论了一些可读流中重要的概念了，这里还有一些你需要知道的方法：</p>
<ol>
<li><code>Readable.pause()</code> - 这个方法会暂停流的流动。换句话说就是它不会再触发 <code>data</code> 事件。</li>
<li><code>Readable.resume()</code> - 这个方法和上面的相反，会让暂停流恢复流动。</li>
<li><code>Readable.unpipe()</code> - 这个方法会把目的地移除。如果有参数传入，它会让可读流停止流向某个特定的目的地，否则，它会移除所有目的地。</li>
</ol>
<h2 id="可写流-Writable-Streams"><a href="#可写流-Writable-Streams" class="headerlink" title="可写流 (Writable Streams)"></a>可写流 (Writable Streams)</h2><p>可写流让你把数据写入目的地。就像可读流那样，这些也是 <code>EventEmitter</code>，它们也会触发不同的事件。我们来看看可写流中会触发的事件和方法吧。</p>
<h3 id="写入流"><a href="#写入流" class="headerlink" title="写入流"></a>写入流</h3><p>要把数据写如到可写流中，你需要在可写流实例中调用 <code>write()</code> 方法，看看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file1.txt'</span>);</div><div class="line"><span class="keyword">var</span> writableStream = fs.createWriteStream(<span class="string">'file2.txt'</span>);</div><div class="line"></div><div class="line">readableStream.setEncoding(<span class="string">'utf8'</span>);</div><div class="line"></div><div class="line">readableStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">  writableStream.write(<span class="string">'chunk'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的代码非常简单，它只是从输入流中读取数据，然后用 <code>write()</code> 写入到目的地中。<br>这个方法返回一个布尔值来表示写入是否成功。如果返回的是 <code>true</code> 那表示写入成功，你可以继续写入更多的数据。 如果是 <code>false</code>，那意味着发生了什么错误，你现在不能继续写入了。可写流会触发一个 <code>drain</code> 事件来告诉你你可以继续写入数据。</p>
<h3 id="写完数据后"><a href="#写完数据后" class="headerlink" title="写完数据后"></a>写完数据后</h3><p>当你不需要在写入数据的时候，你可以调用 <code>end()</code> 方法来告诉流你已经完成写入了。假设 <code>res</code> 是一个 HTTP response 对象，你通常会发送响应给浏览器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">res.write(<span class="string">'Some Data!!'</span>);</div><div class="line">res.end();</div></pre></td></tr></table></figure>
<p>当 <code>end()</code> 被调用时，所有数据会被写入，然后流会触发一个 <code>finish</code> 事件。注意在调用 <code>end()</code> 之后，你就不能再往可写流中写入数据了。例如下面的代码就会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">res.write(<span class="string">'Some Data!!'</span>);</div><div class="line">res.end();</div><div class="line">res.write(<span class="string">'Trying to write again'</span>); <span class="comment">//Error !</span></div></pre></td></tr></table></figure>
<p>这里有一些和可写流相关的重要事件：</p>
<ol>
<li><code>error</code> - 在写入或链接发生错误时触发</li>
<li><code>pipe</code> - 当可读流链接到可写流时，这个事件会触发</li>
<li><code>unpipe</code> -  在可读流调用 <code>unpipe</code> 时会触发</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这些是关于流的基础知识。流，管道，链接是核心，它们是 Node.js 中最强大的功能。如果使用得当，流可以帮助你写出简洁而且高性能的代码。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.sitepoint.com/basics-node-js-streams/" target="_blank" rel="external">https://www.sitepoint.com/basics-node-js-streams/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js 天生异步和事件驱动，非常适合处理 I/O 相关的任务。如果你在处理应用中 I/O 相关的操作，你可以利用 Node.js 中的流(stream)。因此，我们先具体看看流，理解一下它们是怎么简化 I/O 操作的吧。&lt;/p&gt;
&lt;h2 id=&quot;流是什么&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="nodejs" scheme="http://scarletsky.github.io/categories/nodejs/"/>
    
    
      <category term="nodejs" scheme="http://scarletsky.github.io/tags/nodejs/"/>
    
      <category term="stream" scheme="http://scarletsky.github.io/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>升级 GitLab 过程中踩过的坑</title>
    <link href="http://scarletsky.github.io/2016/06/18/issues-when-upgrading-gitlab/"/>
    <id>http://scarletsky.github.io/2016/06/18/issues-when-upgrading-gitlab/</id>
    <published>2016-06-18T11:58:57.000Z</published>
    <updated>2016-06-20T02:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近帮公司的 Gitlab 从 7.14 升级到 8.7.6，升级的主要动机是整合 Gitlab CI，提升持续集成的效率。鉴于之前也是我把 Gitlab 从 7.x 升级到 7.14 的，我以为我已经有经验去处理了，但实际上，这次升级让我踩了不少以前没遇到过的坑…<br>本文主要记录升级 Gitlab 过程中踩过的一些坑~</p>
<h2 id="MySQL-突然启动失败"><a href="#MySQL-突然启动失败" class="headerlink" title="MySQL 突然启动失败"></a>MySQL 突然启动失败</h2><p>由于我们公司的 Gitlab 服务器内存不太够，只有 2G，所以偶尔会出现 500 的错误，但通常情况下，直接通过 <code>$ sudo service gitlab restart</code> 重启一次服务就可以恢复正常了。<br>但是，最近我遇到过 gitlab 启动失败，原因是 MySQL 无法启动。<br>当我启动 MySQL 的时候，报了这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo service mysql restart</div><div class="line">...</div><div class="line">MySQL Job failed to start</div></pre></td></tr></table></figure>
<p>报错就报错吧，去看看 error.log 就好了吧。 然而，我太天真了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cat /var/log/mysql/error.log</div><div class="line">$ cat /var/log/mysql/mysql.log</div></pre></td></tr></table></figure>
<p>MySQL 的 error.log 是空的，mysql.log 也是空的…太诡异了，没 log 怎么 debug ?<br>还好有万能的 google，我找到了类似情况的问题：<a href="http://stackoverflow.com/questions/22909060/mysql-job-failed-to-start" target="_blank" rel="external">mysql-job-failed-to-start</a>。最高票的答案是重装 mysql 的，但我不敢冒这个风险。我注意到有个回答说：</p>
<blockquote>
<p>The given solution requires enough free HDD</p>
</blockquote>
<p>于是我马上查了一下硬盘空间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ df -h</div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">/dev/xvda1       20G   20G  0G   100% /</div><div class="line">...</div></pre></td></tr></table></figure>
<p>原来是空间满了，于是我删掉了一些没用的东西，腾出了 3G 多的空间之后，MySQL 又可以正常启动了，Gitlab 也是！</p>
<h2 id="迁移-MySQL-到-PostgreSQL-时找不到依赖"><a href="#迁移-MySQL-到-PostgreSQL-时找不到依赖" class="headerlink" title="迁移 MySQL 到 PostgreSQL 时找不到依赖"></a>迁移 MySQL 到 PostgreSQL 时找不到依赖</h2><p>以前一直听说 PostgreSQL 很强大，而 Gitlab 也是官方推荐使用 PostgreSQL，再加上 Gitlab 有官方教程教我们如何把 MySQL 迁移到 PostgreSQL，于是我就萌生了迁移数据库的念头。</p>
<p>按照着 <a href="https://gitlab.com/gitlab-org/gitlab-ce/blob/master/doc/update/mysql_to_postgresql.md" target="_blank" rel="external">Migrating GitLab from MySQL to Postgres</a> 这篇文章，我很轻易就把 MySQL 中的数据迁移到 PostgreSQL 中了。<br>而且每个步骤都没报错，我以为一切正常，谁知道当我执行 <code>service gitlab start</code> 的时候，就报启动失败了。</p>
<p>我一下子就懵了，为什么按照官方教程做还会报错？ 而且报的还是这种抱不到依赖的错误？<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Specified &apos;postgresql&apos; for database adapter, but the gem is not loaded. Add `gem &apos;pg&apos;` to your Gemfile.</div></pre></td></tr></table></figure></p>
<p>我找了很多资料，但基本都是说把 <code>pg</code> 加到 Gemfile ，然后再 <code>bundle install</code> 就好了。<br>但我试过把 <code>vendor/bundle</code> 删掉再重装，还是有这个错误。<br>最后，我找到 <a href="https://gitlab.com/gitlab-org/gitlab-ci/issues/227" target="_blank" rel="external">Gem::LoadError: Specified ‘mysql2’ after update to 7.13
</a> 这个 issue，里面提到在 <code>.bundle/config</code> 里面有一些 bundle 的配置！我发现我里面的配置和这个 issue 提到的配置是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BUNDLE_WITHOUT: development:test:postgres:mysql</div></pre></td></tr></table></figure>
<p>最后，我把上面的 <code>postgres</code> 部分删掉，然后再运行 <code>sudo -u git -H bundle install --without development test mysql --deployment</code> 安装依赖，就能正常启动 gitlab 了。</p>
<p>这时候，我才体会到，不熟悉 ruby 技术栈去搞 gitlab 真是累啊~</p>
<h2 id="Docker-化时自动修改用户组引起其他问题"><a href="#Docker-化时自动修改用户组引起其他问题" class="headerlink" title="Docker 化时自动修改用户组引起其他问题"></a>Docker 化时自动修改用户组引起其他问题</h2><p><strong>严格来说这不是升级 Gitlab 升级过程中遇到的坑，这只是我在尝试把 gitlab docker 化时遇到的问题。</strong></p>
<p>有了上面的经历，我暗下决心，要把 Gitlab Docker 化，这样我就不用操心 Gitlab 相关的问题了，我只要启动下载镜像，运行容器就好了，其他 Gitlab 相关的事情就交回给官方处理好了。</p>
<p>于是，我找到了 <a href="https://github.com/sameersbn/docker-gitlab" target="_blank" rel="external">docker-gitlab</a>，我慢慢去尝试把 Gitlab 扔到 docker 里面运行。</p>
<p>最开始的时候，我直接用 docker-compose 来运行 docker-gitlab，我试着先用 MySQL ，于是我把 <code>docker-compose.yaml</code> 中的 PostgreSQL 部分的东西全部改成 MySQL，然后直接用 <code>docker-compose up</code> 来运行 gitlab 。</p>
<p>虽然运行过程中没看出什么问题，但我后来发现 MySQL 中的用户和用户组都被修改成 <code>messagebus:fuse</code> 了！这样直接导致了我本地的 MySQL 不能正常使用了。</p>
<p>经过调查，我发现是 docker 的 <code>-v</code> 指定已存在目录的时候，会修改文件目录的用户和用户组，最后把它改回 <code>mysql:adm</code> 才恢复正常~</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://stackoverflow.com/questions/22909060/mysql-job-failed-to-start" target="_blank" rel="external">http://stackoverflow.com/questions/22909060/mysql-job-failed-to-start</a><br><a href="https://gitlab.com/gitlab-org/gitlab-ci/issues/227" target="_blank" rel="external">https://gitlab.com/gitlab-org/gitlab-ci/issues/227</a><br><a href="https://github.com/sameersbn/docker-gitlab" target="_blank" rel="external">https://github.com/sameersbn/docker-gitlab</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近帮公司的 Gitlab 从 7.14 升级到 8.7.6，升级的主要动机是整合 Gitlab CI，提升持续集成的效率。鉴于之前也是我把
    
    </summary>
    
    
      <category term="gitlab" scheme="http://scarletsky.github.io/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>「译」 MapReduce in MongoDB</title>
    <link href="http://scarletsky.github.io/2016/06/12/mapreduce-in-mongodb/"/>
    <id>http://scarletsky.github.io/2016/06/12/mapreduce-in-mongodb/</id>
    <published>2016-06-12T02:04:53.000Z</published>
    <updated>2016-06-12T06:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章里面，我们会演示如何在 MongoDB 中使用 MapReduce 操作。<br>我们会用 <code>dummy-json</code> 这个包来生成一些虚假的数据，然后用 <code>Mongojs</code></p>
<p>如果想要快速看到结果，可以到 <a href="http://code.runnable.com/U1fmE30iHWMIGY_r/mapreduce-in-mongodb-for-node-js" target="_blank" rel="external">这里</a> 里看看。</p>
<h2 id="什么是-MongoDB"><a href="#什么是-MongoDB" class="headerlink" title="什么是 MongoDB ?"></a>什么是 MongoDB ?</h2><p>MongoDB 是一个 NoSQL 数据库，不像 MySQL 、MSSQL 和 Oracle DB 那样，MongoDB 使用集合(collections) 来代替表(tables)。同时，它用集合中的文档(documents)来代替表中的行(rows)。还有最好的一点是，所有文档都保存成 JSON 格式！你可以到<a href="http://try.mongodb.org/" target="_blank" rel="external">这里</a>学更多关于 MongoDB 的知识。</p>
<p>你可以从 <a href="http://www.mongodb.org/downloads" target="_blank" rel="external">这里</a> 下载安装 MongoDB。</p>
<p>如果以前没用过 MongoDB，那么你可以记住下面这些命令:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mongod</code></td>
<td>启动 MongoDB 服务</td>
</tr>
<tr>
<td><code>mongo</code></td>
<td>进入 MongoDB Shell</td>
</tr>
<tr>
<td><code>show dbs</code></td>
<td>显示所有数据库列表</td>
</tr>
<tr>
<td><code>use &lt;db name&gt;</code></td>
<td>进入指定的数据库</td>
</tr>
<tr>
<td><code>show collections</code></td>
<td>进入数据库之后，显示该数据库中所有的集合</td>
</tr>
<tr>
<td><code>db.collectionName.find()</code></td>
<td>显示该集合中所有文档</td>
</tr>
<tr>
<td><code>db.collectionName.findOne()</code></td>
<td>显示该集合中第一个文档</td>
</tr>
<tr>
<td><code>db.collectionName.find().pretty()</code></td>
<td>显示漂亮的 JSON 格式</td>
</tr>
<tr>
<td><code>db.collectionName.insert({key: value})</code></td>
<td>插入一条新的记录</td>
</tr>
<tr>
<td><code>db.collectionName.update({ condition: value}, {$set: {key: value}}, {upsert: true})</code></td>
<td>会更新指定的文档，设置指定的值。如果 <code>upsert</code> 为 <code>true</code>，当没有找到匹配的文档时，会创建一条新的记录</td>
</tr>
<tr>
<td><code>db.collectionName.remove({})</code></td>
<td>移除集合中的所有文档</td>
</tr>
<tr>
<td><code>db.collectionName.remove({key: value})</code></td>
<td>移除集合中匹配到的文档</td>
</tr>
</tbody>
</table>
<h2 id="什么是-MapReduce"><a href="#什么是-MapReduce" class="headerlink" title="什么是 MapReduce ?"></a>什么是 MapReduce ?</h2><p>弄清楚 MapReduce 是如何运作的是非常重要的，如果对 MapReduce 过程不了解的话，你在运行 MapReduce 时很可能得不到你想要的结果。</p>
<p>从 mongodb.org 上的解析：</p>
<blockquote>
<p>Map-reduce 是一种数据处理范例，用于将大量的数据变成有用的聚合结果。 对于 map-reduce 操作，MongoDB 提供了 mapReduce 的数据库命令。</p>
</blockquote>
<p>在这非常简单的术语里面，mapReduce 命令接受两个基本的输入：mapper 函数和 reducer 函数。</p>
<p>Mapper 是一个匹配数据的过程，它会在集合中查询我们想要处理的字段，然后根据我们指定的 key 去分组，再把这些 key-value 对交给 reducer 函数，由它来处理这些匹配到的数据。</p>
<p>我们来看看下面这些数据：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">[</div><div class="line">  &#123; name: foo, price: 9 &#125;,</div><div class="line">  &#123; name: foo, price: 12 &#125;,</div><div class="line">  &#123; name: bar, price: 8 &#125;,</div><div class="line">  &#123; name: baz, price: 3 &#125;,</div><div class="line">  &#123; name: baz, price: 5 &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>我们想要计算出相同名字下的所需要的价钱。我们将会用这个数据通过 Mapper 和 Reducer 去获得结果。</p>
<p>当我们让 Mapper 去处理上面的数据时，会生成如下的结果：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>foo</td>
<td>[9,12]</td>
</tr>
<tr>
<td>bar</td>
<td>[8]</td>
</tr>
<tr>
<td>baz</td>
<td>[3,5]</td>
</tr>
</tbody>
</table>
<p>看到了吗？它用相同的 key 去分组数据。在我们的例子中，是用 name 分组。这些结果会发送到 Reducer 中。</p>
<p>现在，在 reducer 中，我们会得到上面表格中的第一行数据，然后迭代这些数据然后把它们加起来，这就是第一行数据的总和。然后 reducer 会对第二行数据做同样的事情，直到所有行被处理完。</p>
<p>最终的输出结果如下：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Total</th>
</tr>
</thead>
<tbody>
<tr>
<td>foo</td>
<td>21</td>
</tr>
<tr>
<td>bar</td>
<td>8</td>
</tr>
<tr>
<td>baz</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>现在你明白为什么 Mapper 会叫 Mapper 了吧 ! (因为它会创建一份数据的映射)<br>也明白了为什么 Reducer 会叫 Reducer 了吧 ! (因为它会把 Mapper 生成的数据归纳成一个简单的形式)</p>
<p>如果你运行一些例子，你就会知道它是怎么工作的拉。你也可以从<a href="https://docs.mongodb.com/manual/core/map-reduce/" target="_blank" rel="external">官方文档</a> 中了解更多细节。</p>
<h2 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h2><p>正如上文所说，我们可以在 mongo shell 中直接查询和看到输出结果。但是，为了让教程更加丰富，我们会构建一个 Nodejs 项目，在里面运行我们之前的任务。</p>
<h3 id="Mongojs"><a href="#Mongojs" class="headerlink" title="Mongojs"></a>Mongojs</h3><p>我们会用 <code>mongojs</code> 去实现我们的 MapReduce。你可以用同样的代码跑在 mongo shell 里面，会看到同样的结果。</p>
<h3 id="Dummy-json"><a href="#Dummy-json" class="headerlink" title="Dummy-json"></a>Dummy-json</h3><p>我们会用 <code>dummy-json</code> 去创建一些虚假的数据。你可以在 <a href="https://github.com/webroo/dummy-json" target="_blank" rel="external">这里</a> 找到更多的信息。然后我们会在这些虚假数据上面运行 MapReduce 命令，生成一些有意义的结果。</p>
<p>我们开始吧！</p>
<p>首先，你要安装 Nodejs，你可以看看 <a href="http://thejackalofjavascript.com/hello-node/" target="_blank" rel="external">这里</a>。然后你要创建一个叫 mongoDBMapReduce 的目录。我们将会创建 <code>package.json</code> 文件来保存项目的详细信息。</p>
<p>运行 <code>npm init</code> 然后填入你喜欢的东西，创建完 <code>package.json</code> 后，我们要添加项目的依赖。<br>运行 <code>npm i mongojs dummy-json --save-dev</code> ，然后等几分钟之后，我们项目的依赖就安装好了。</p>
<h2 id="生成虚假数据"><a href="#生成虚假数据" class="headerlink" title="生成虚假数据"></a>生成虚假数据</h2><p>下一步，我们要用 <code>dummy-json</code> 模块来生成虚假数据。<br>在项目的根目录创建一个名叫 <code>dataGen.js</code> 的文件，我们会把数据生成的逻辑保存到一个独立的文件里面。如果以后需要添加更多的数据，你可以运行这个文件。</p>
<p>把下面的内容复制到 <code>dataGen.js</code> 里面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mongojs = <span class="built_in">require</span>(<span class="string">'mongojs'</span>);</div><div class="line"><span class="keyword">var</span> db = mongojs(<span class="string">'mapReduceDB'</span>, [<span class="string">'sourceData'</span>]);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> dummyjson = <span class="built_in">require</span>(<span class="string">'dummy-json'</span>);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> helpers = &#123;</div><div class="line">  <span class="attr">gender</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>+ <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="string">'male'</span> : <span class="string">'female'</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">dob</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1900</span>, <span class="number">0</span>, <span class="number">1</span>),</div><div class="line">        end = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(start.getTime() + <span class="built_in">Math</span>.random() * (end.getTime() - start.getTime()));</div><div class="line">    &#125;,</div><div class="line">  <span class="attr">hobbies</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hobbysList = []; </div><div class="line">    hobbysList[<span class="number">0</span>] = [];</div><div class="line">    hobbysList[<span class="number">0</span>][<span class="number">0</span>] = [<span class="string">"Acrobatics"</span>, <span class="string">"Meditation"</span>, <span class="string">"Music"</span>];</div><div class="line">    hobbysList[<span class="number">0</span>][<span class="number">1</span>] = [<span class="string">"Acrobatics"</span>, <span class="string">"Photography"</span>, <span class="string">"Papier-Mache"</span>];</div><div class="line">    hobbysList[<span class="number">0</span>][<span class="number">2</span>] = [ <span class="string">"Papier-Mache"</span>];</div><div class="line">    <span class="keyword">return</span> hobbysList[<span class="number">0</span>][<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * hobbysList[<span class="number">0</span>].length)];</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Begin Parsing &gt;&gt;"</span>);</div><div class="line"> </div><div class="line"><span class="keyword">var</span> template = fs.readFileSync(<span class="string">'schema.hbs'</span>, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;);</div><div class="line"><span class="keyword">var</span> result = dummyjson.parse(template, &#123;<span class="attr">helpers</span>: helpers&#125;);</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Begin Database Insert &gt;&gt;"</span>);</div><div class="line"> </div><div class="line">db.sourceData.remove(<span class="function"><span class="keyword">function</span> (<span class="params">argument</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"DB Cleanup Completd"</span>);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">db.sourceData.insert(<span class="built_in">JSON</span>.parse(result), <span class="function"><span class="keyword">function</span> (<span class="params">err, docs</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"DB Insert Completed"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>第1-4行</strong>，我们引入了所有依赖。<br><strong>第2行</strong>，我们创建了一个叫 <code>mapReduceDB</code> 的数据库。在数据库里面，创建了一个叫 <code>sourceData</code> 的集合。</p>
<p><strong>第6-23行</strong>，是 Handlebar 的 helper。你可以到 <code>dummy-json</code> 中了解更多信息。</p>
<p><strong>第27-28行</strong>，我们读取了 <code>schema.hbs</code> 文件 (我们接着会创建这个文件)，然后把它解析成 JSON。</p>
<p><strong>第32行</strong>，在插入新数据之前，我们要先把旧数据清除掉。如果你想保留旧数据，把这部分注释掉就好了。</p>
<p><strong>第36行</strong>，把生成的数据插入数据库。</p>
<p>接着，我们要在项目根目录创建一个叫 <code>schema.hbs</code> 的文件。这里面会包括 JSON 文档的结构。把下面的内容复制到文件里面：</p>
<figure class="highlight hbs"><table><tr><td class="code"><pre><div class="line"><span class="xml">[</span></div><div class="line">    <span class="template-tag">&#123;&#123;#<span class="name">repeat</span> 9999&#125;&#125;</span><span class="xml"></span></div><div class="line">    &#123;</div><div class="line">      "id": <span class="template-variable">&#123;&#123;index&#125;&#125;</span><span class="xml">,</span></div><div class="line">      "name": "<span class="template-variable">&#123;&#123;firstName&#125;&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123;lastName&#125;&#125;</span><span class="xml">",</span></div><div class="line">      "email": "<span class="template-variable">&#123;&#123;email&#125;&#125;</span><span class="xml">",</span></div><div class="line">      "work": "<span class="template-variable">&#123;&#123;company&#125;&#125;</span><span class="xml">",</span></div><div class="line">      "dob" : "<span class="template-variable">&#123;&#123;dob&#125;&#125;</span><span class="xml">",</span></div><div class="line">      "age": <span class="template-variable">&#123;&#123;number 1 99&#125;&#125;</span><span class="xml">,</span></div><div class="line">      "gender" : "<span class="template-variable">&#123;&#123;gender&#125;&#125;</span><span class="xml">",</span></div><div class="line">      "salary" : <span class="template-variable">&#123;&#123;number 999 99999&#125;&#125;</span><span class="xml">,</span></div><div class="line">      "hobbies" : "<span class="template-variable">&#123;&#123;hobbies&#125;&#125;</span><span class="xml">"</span></div><div class="line">    &#125;</div><div class="line">    <span class="template-tag">&#123;&#123;/<span class="name">repeat</span>&#125;&#125;</span><span class="xml"></span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>注意 <strong>第2行</strong>，我们会生成 9999 个文档。</p>
<p>打开一个新的终端，运行 <code>mongod</code>，启动 MongoDB 服务。然后回到原来的终端，运行 <code>node dataGen.js</code>。</p>
<p>如果一切正常，会显示如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ node dataGen.js</div><div class="line">Begin Parsing &gt;&gt;</div><div class="line">Begin Database Insert &gt;&gt;</div><div class="line">DB Cleanup Completed</div><div class="line">DB Insert Completed</div></pre></td></tr></table></figure>
<p>然后按 ctrl + c 杀掉 Node 程序。要验证是否插入成功，我们可以打开一个新的终端，运行 <code>mongo</code> 命令进入 mongo shell。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; use mapReduceDB</div><div class="line">&gt; db.sourceData.findOne()</div><div class="line">&#123;</div><div class="line">    &quot;id&quot;: 0,</div><div class="line">    &quot;name&quot;: &quot;Leanne Flinn&quot;,</div><div class="line">    &quot;email&quot;: &quot;leanne.flinn@unilogic.com&quot;,</div><div class="line">    &quot;work&quot;: &quot;Unilogic&quot;,</div><div class="line">    &quot;dob&quot;: &quot;Sun Mar 14 1909 12:45:53 GTM+0530 (LST)&quot;,</div><div class="line">    &quot;age&quot;: 27,</div><div class="line">    &quot;gender&quot;: &quot;male&quot;,</div><div class="line">    &quot;salary&quot;: 16660,</div><div class="line">    &quot;hobbies&quot;: &quot;Acrobatics,Photography,Papier-Mache&quot;,</div><div class="line">    &quot;_id&quot;: Object(&quot;57579f702fa6c7651e504fe2&quot;)</div><div class="line">&#125;</div><div class="line">&gt; db.sourceData.count()</div><div class="line">9999</div></pre></td></tr></table></figure>
<h2 id="有意义的数据"><a href="#有意义的数据" class="headerlink" title="有意义的数据"></a>有意义的数据</h2><p>现在我们有 9999 个虚假用户的数据，让我们试着把数据变得有意义</p>
<h3 id="例子1：计算男女数量"><a href="#例子1：计算男女数量" class="headerlink" title="例子1：计算男女数量"></a>例子1：计算男女数量</h3><p>首先，在项目根目录创建一个 <code>example1.js</code> 的文件，我们要进行 MapReduce 操作，去计算男女的数量。</p>
<h4 id="Mapper-的逻辑"><a href="#Mapper-的逻辑" class="headerlink" title="Mapper 的逻辑"></a>Mapper 的逻辑</h4><p>我们只需要让 Mapper 以性别作为 key，把值作为 1。因为一个用户不是男就是女。所以，Mapper 的输出会是下面这样：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Male</td>
<td>[1,1,1…]</td>
</tr>
<tr>
<td>Female</td>
<td>[1,1,1,1,1…]</td>
</tr>
</tbody>
</table>
<h4 id="Reducer-的逻辑"><a href="#Reducer-的逻辑" class="headerlink" title="Reducer 的逻辑"></a>Reducer 的逻辑</h4><p>在 Reducer 中，我们会获得上面两行数据，我们要做的是把每一行中的值求和，表示该性别的总数。最终的输出结果如下：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Male</td>
<td>5031</td>
</tr>
<tr>
<td>Female</td>
<td>4968</td>
</tr>
</tbody>
</table>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>好了，现在我们可以写代码去实现了。在 <code>example1.js</code> 中，我们要先引入所需要的依赖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mongojs = <span class="built_in">require</span>(<span class="string">'mongojs'</span>);</div><div class="line"><span class="keyword">var</span> db = mongojs(<span class="string">'mapReduceDB'</span>, [<span class="string">'sourceData'</span>, <span class="string">'example1_results'</span>]);</div></pre></td></tr></table></figure>
<p>注意 <strong>第2行</strong>，第一个参数是数据库的名字，第二个参数表示集合的数组。<code>example1_results</code> 集合用来保存结果。</p>
<p>接下来，我们加上 mapper 和 reducer 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mapper = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    emit(<span class="keyword">this</span>.gender, <span class="number">1</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span>(<span class="params">gender, count</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.sum(count);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在<strong>第2行</strong>中， <code>this</code> 表示当前的文档，因此 <code>this.gender</code> 会作为 mapper 的 key，它的值要么是 <code>male</code>，要么是 <code>female</code>。而 <code>emit()</code> 将会把数据发送到一个临时保存数据的地方，作为 mapper 的结果。</p>
<p>在<strong>第5行</strong>中，我们简单地把每个性别的所有值加起来。</p>
<p>最后，加上执行逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">db.sourceData.mapReduce(</div><div class="line">    mapper,</div><div class="line">    reducer,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">out</span> : <span class="string">"example1_results"</span></div><div class="line">    &#125;</div><div class="line"> );</div><div class="line"> </div><div class="line"> db.example1_results.find(<span class="function"><span class="keyword">function</span> (<span class="params">err, docs</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(err);</div><div class="line">    <span class="built_in">console</span>.log(docs);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>在<strong>第5行</strong>中，我们设置了输出的集合名。<br>在<strong>第9行</strong>中，我们会从 <code>example1_results</code> 集合取得结果并显示它。</p>
<p>我们可以在终端运行试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ node example1.js</div><div class="line">[ &#123; _id: &apos;female&apos;, value: 4968 &#125;, &#123; _id: &apos;male&apos;: value: 5031 &#125; ]</div></pre></td></tr></table></figure>
<p>我的数量可能和你的不一样，但男女总数应该是 9999 !</p>
<h4 id="Mongo-Shell-代码"><a href="#Mongo-Shell-代码" class="headerlink" title="Mongo Shell 代码"></a>Mongo Shell 代码</h4><p>如果你想在 mongo shell 中运行上面的例子，你可以粘贴下面这些代码到终端里面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">mapper = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    emit(<span class="keyword">this</span>.gender, <span class="number">1</span>);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">reducer = <span class="function"><span class="keyword">function</span>(<span class="params">gender, count</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.sum(count);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">db.sourceData.mapReduce(</div><div class="line">    mapper,</div><div class="line">    reducer,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">out</span> : <span class="string">"example1_results"</span></div><div class="line">    &#125;</div><div class="line"> );</div><div class="line"> </div><div class="line"> db.example1_results.find()</div></pre></td></tr></table></figure>
<p>然后你就会看到一样的结果，很简单吧！</p>
<h3 id="例子2：获取每个性别中最老和最年轻的人"><a href="#例子2：获取每个性别中最老和最年轻的人" class="headerlink" title="例子2：获取每个性别中最老和最年轻的人"></a>例子2：获取每个性别中最老和最年轻的人</h3><p>在项目根目录创建一个 <code>example2.js</code> 的文件。在这里，我们要把所有用户根据性别分组，然后分别找每个性别中最老和最年轻的用户。这个例子比前面的稍微复杂一点。</p>
<h4 id="Mapper-的逻辑-1"><a href="#Mapper-的逻辑-1" class="headerlink" title="Mapper 的逻辑"></a>Mapper 的逻辑</h4><p>在 mapper 中，我们要以性别作为 key，然后以 object 作为 value。这个 object 要包含用户的年龄和名字。年龄是用来做计算用的，而名字只是用来显示给人看的。</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Male</td>
<td>[{age: 9, name: ‘John’}, …]</td>
</tr>
<tr>
<td>Female</td>
<td>[{age: 19, name: ‘Rita’}, …]</td>
</tr>
</tbody>
</table>
<h4 id="Reducer-的逻辑-1"><a href="#Reducer-的逻辑-1" class="headerlink" title="Reducer 的逻辑"></a>Reducer 的逻辑</h4><p>我们的 reducer 会比前一个例子要复杂一点。我们要检查所有和性别相关的年龄，找到年龄最大和最小的用户。最终的输出结果是这样的：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Male</td>
<td>{min: {name: ‘harry’, age: 1}, max: {name: ‘Alex’, age: 99} }</td>
</tr>
<tr>
<td>Female</td>
<td>{min: {name: ‘Loli’, age: 10}, max: {name: ‘Mary’, age: 98} }</td>
</tr>
</tbody>
</table>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>现在打开 <code>example2.js</code>，粘贴下面的内容进去：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mongojs = <span class="built_in">require</span>(<span class="string">'mongojs'</span>);</div><div class="line"><span class="keyword">var</span> db = mongojs(<span class="string">'mapReduceDB'</span>, [<span class="string">'sourceData'</span>, <span class="string">'example2_results'</span>]);</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">var</span> mapper = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = &#123;<span class="attr">age</span> : <span class="keyword">this</span>.age, <span class="attr">name</span> : <span class="keyword">this</span>.name&#125;;</div><div class="line">    emit(<span class="keyword">this</span>.gender, &#123;<span class="attr">min</span> : x , <span class="attr">max</span> : x&#125;);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span>(<span class="params">key, values</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> res = values[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; values.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span>(values[i].min.age &lt; res.min.age)</div><div class="line">            res.min = &#123;<span class="attr">name</span> : values[i].min.name, <span class="attr">age</span> : values[i].min.age&#125;;</div><div class="line">        <span class="keyword">if</span> (values[i].max.age &gt; res.max.age) </div><div class="line">           res.max = &#123;<span class="attr">name</span> : values[i].max.name, <span class="attr">age</span> : values[i].max.age&#125;;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"> </div><div class="line">db.sourceData.mapReduce(</div><div class="line">    mapper,</div><div class="line">    reducer,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">out</span> : <span class="string">"example2_results"</span></div><div class="line">    &#125;</div><div class="line"> );</div><div class="line"> </div><div class="line"> db.example2_results.find(<span class="function"><span class="keyword">function</span> (<span class="params">err, docs</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(err);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(docs));</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>在<strong>第6行</strong>，我们构建了一个 object，把它作为 value 发送。<br>在<strong>第13-18行</strong>，我们迭代了所有 object，检查当前的 object 的年龄是否大于或小于前一个 object 的年龄，如果是，就会更新 <code>res.max</code> 或者 <code>res.min</code>。<br>在第<strong>第27行</strong>，我们把结果输出到 <code>example2_results</code> 中。</p>
<p>我们可以运行一下这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ node example2.js</div><div class="line">[ &#123; _id: &apos;female&apos;, value: &#123; min: [Object], max: [Object] &#125; &#125;,</div><div class="line">  &#123; _id: &apos;male&apos;, value: &#123; min: [Object], max: [Object] &#125; &#125; ]</div></pre></td></tr></table></figure>
<h3 id="例子3：计算每种兴趣爱好的人数"><a href="#例子3：计算每种兴趣爱好的人数" class="headerlink" title="例子3：计算每种兴趣爱好的人数"></a>例子3：计算每种兴趣爱好的人数</h3><p>在我们最后的例子中，我们会看看有多少用户有相同的兴趣爱好。我们在项目根目录创建一个叫 <code>example3.js</code> 的文件。用户数据长这样子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"id"</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">"name"</span>: <span class="string">"Leanne Flinn"</span>,</div><div class="line">    <span class="attr">"email"</span>: <span class="string">"leanne.flinn@unilogic.com"</span>,</div><div class="line">    <span class="attr">"work"</span>: <span class="string">"Unilogic"</span>,</div><div class="line">    <span class="attr">"dob"</span>: <span class="string">"Sun Mar 14 1909 12:45:53 GTM+0530 (LST)"</span>,</div><div class="line">    <span class="attr">"age"</span>: <span class="number">27</span>,</div><div class="line">    <span class="attr">"gender"</span>: <span class="string">"male"</span>,</div><div class="line">    <span class="attr">"salary"</span>: <span class="number">16660</span>,</div><div class="line">    <span class="attr">"hobbies"</span>: <span class="string">"Acrobatics,Photography,Papier-Mache"</span>,</div><div class="line">    <span class="attr">"_id"</span>: Object(<span class="string">"57579f702fa6c7651e504fe2"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所见，每个用户的兴趣爱好列表都用逗号分隔。我们会找出有多少用户有表演杂技的爱好等等。</p>
<h4 id="Mapper-的逻辑-2"><a href="#Mapper-的逻辑-2" class="headerlink" title="Mapper 的逻辑"></a>Mapper 的逻辑</h4><p>在这个场景下，我们的 mapper 会复杂一点。我们要为每个用户的兴趣爱好发送一个新的 key-value 对。这样，每个用户的每个兴趣爱好都会触发一次计算。最终我们会得到如下的结果：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Acrobatics</td>
<td>[1,1,1,1,1,1,….]</td>
</tr>
<tr>
<td>Meditation</td>
<td>[1,1,1,1,1,1,….]</td>
</tr>
<tr>
<td>Music</td>
<td>[1,1,1,1,1,1,….]</td>
</tr>
<tr>
<td>Photography</td>
<td>[1,1,1,1,1,1,….]</td>
</tr>
<tr>
<td>Papier-Mache</td>
<td>[1,1,1,1,1,1,….]</td>
</tr>
</tbody>
</table>
<h4 id="Reducer-的逻辑-2"><a href="#Reducer-的逻辑-2" class="headerlink" title="Reducer 的逻辑"></a>Reducer 的逻辑</h4><p>在这里，我们只要简单地为每种兴趣爱好求和就好了。最终我们会得到下面的结果：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Acrobatics</td>
<td>6641</td>
</tr>
<tr>
<td>Meditation</td>
<td>3338</td>
</tr>
<tr>
<td>Music</td>
<td>3338</td>
</tr>
<tr>
<td>Photography</td>
<td>3303</td>
</tr>
<tr>
<td>Papier-Mache</td>
<td>6661</td>
</tr>
</tbody>
</table>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mongojs = <span class="built_in">require</span>(<span class="string">'mongojs'</span>);</div><div class="line"><span class="keyword">var</span> db = mongojs(<span class="string">'mapReduceDB'</span>, [<span class="string">'sourceData'</span>, <span class="string">'example3_results'</span>]);</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">var</span> mapper = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> hobbys = <span class="keyword">this</span>.hobbies.split(<span class="string">','</span>);</div><div class="line">      <span class="keyword">for</span> (i <span class="keyword">in</span> hobbys) &#123;</div><div class="line">        emit(hobbys[i], <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">key, values</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> values) &#123;</div><div class="line">        count += values[index];</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"> </div><div class="line">db.sourceData.mapReduce(</div><div class="line">    mapper,</div><div class="line">    reducer,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">out</span> : <span class="string">"example3_results"</span></div><div class="line">    &#125;</div><div class="line"> );</div><div class="line"> </div><div class="line"> db.example3_results.find(<span class="function"><span class="keyword">function</span> (<span class="params">err, docs</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(err);</div><div class="line">    <span class="built_in">console</span>.log(docs);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>注意<strong>第7-9行</strong>，我们迭代了每个兴趣爱好，然后发送了一次记数。<br><strong>第13-18行</strong>可以用 <code>Array.sum(values)</code> 来代替，这样是另外一种做相同事情的方式。最终我们得到的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ node example3.js</div><div class="line">[ &#123; _id: &apos;Acrobatics&apos;, value: 6641 &#125;,</div><div class="line">  &#123; _id: &apos;Meditation&apos;, value: 3338 &#125;,</div><div class="line">  &#123; _id: &apos;Music&apos;, value: 3338 &#125;,</div><div class="line">  &#123; _id: &apos;Photography&apos;, value: 6661 &#125;,</div><div class="line">  &#123; _id: &apos;Papier-Mache&apos;, value: 3303 &#125; ]</div></pre></td></tr></table></figure>
<p>这就是 MongoDB 中运行 MapReduce 的方法了。但要记住，有时候一个简单的查询就能完成你想要的事情的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://thejackalofjavascript.com/mapreduce-in-mongodb/" target="_blank" rel="external">MapReduce in MongoDB</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章里面，我们会演示如何在 MongoDB 中使用 MapReduce 操作。&lt;br&gt;我们会用 &lt;code&gt;dummy-json&lt;/code&gt; 这个包来生成一些虚假的数据，然后用 &lt;code&gt;Mongojs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果想要快速看到结果，可以到 &lt;
    
    </summary>
    
    
      <category term="mongodb" scheme="http://scarletsky.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>编写 Hubot Scripts</title>
    <link href="http://scarletsky.github.io/2016/05/02/write-your-own-hubot-scripts/"/>
    <id>http://scarletsky.github.io/2016/05/02/write-your-own-hubot-scripts/</id>
    <published>2016-05-02T08:05:37.000Z</published>
    <updated>2016-05-10T05:04:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们在上一篇中介绍了 Hubot 的简单用法，里面提到我们可以为机器人编写脚本来让它根据不同的「输入」来给出不同的「输出」。<br>本文将会介绍如何编写我们的 Hubot Scritps。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>我们的脚本应该放在哪里才能让 hubot 找到并且正常加载呢？在上一篇文章中我们提到过，hubot 在启动时会加载 <code>scripts/</code> 目录中的脚本文件。<br>但它到底是怎么加载的呢？我们可以打开 <code>bin/hubot</code> 文件看一下：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"># ......</div><div class="line">loadScripts = -&gt;</div><div class="line">  # 加载 scripts 中的脚本</div><div class="line">  scriptsPath = Path.resolve &quot;.&quot;, &quot;scripts&quot;</div><div class="line">  robot.load scriptsPath</div><div class="line"></div><div class="line">  # 加载 src/scripts 中的脚本</div><div class="line">  scriptsPath = Path.resolve &quot;.&quot;, &quot;src&quot;, &quot;scripts&quot;</div><div class="line">  robot.load scriptsPath</div><div class="line"></div><div class="line">  # 加载 hubot-scripts.json 中列出的脚本</div><div class="line">  hubotScripts = Path.resolve &quot;.&quot;, &quot;hubot-scripts.json&quot;</div><div class="line">  if Fs.existsSync(hubotScripts)</div><div class="line">    data = Fs.readFileSync(hubotScripts)</div><div class="line">    if data.length &gt; 0</div><div class="line">      try</div><div class="line">        scripts = JSON.parse data</div><div class="line">        scriptsPath = Path.resolve &quot;node_modules&quot;, &quot;hubot-scripts&quot;, &quot;src&quot;, &quot;scripts&quot;</div><div class="line">        robot.loadHubotScripts scriptsPath, scripts</div><div class="line">      catch err</div><div class="line">        console.error &quot;Error parsing JSON data from hubot-scripts.json: #&#123;err&#125;&quot;</div><div class="line">        process.exit(1)</div><div class="line"></div><div class="line">  # 加载 external-scripts.json 中列出的脚本</div><div class="line">  externalScripts = Path.resolve &quot;.&quot;, &quot;external-scripts.json&quot;</div><div class="line">  if Fs.existsSync(externalScripts)</div><div class="line">    Fs.readFile externalScripts, (err, data) -&gt;</div><div class="line">      if data.length &gt; 0</div><div class="line">        try</div><div class="line">          scripts = JSON.parse data</div><div class="line">        catch err</div><div class="line">          console.error &quot;Error parsing JSON data from external-scripts.json: #&#123;err&#125;&quot;</div><div class="line">          process.exit(1)</div><div class="line">        robot.loadExternalScripts scripts</div><div class="line"></div><div class="line">  # 加载由 process.env.HUBOT_SCRIPTS 和 -r 参数指定的脚本</div><div class="line">  for path in Options.scripts</div><div class="line">    if path[0] == &apos;/&apos;</div><div class="line">      scriptsPath = path</div><div class="line">    else</div><div class="line">      scriptsPath = Path.resolve &quot;.&quot;, path</div><div class="line">    robot.load scriptsPath</div><div class="line"># ......</div></pre></td></tr></table></figure>
<p>其实只是先指定脚本路径，然后调用 <code>robot.load</code> 和 <code>robot.loadHubotScripts</code> 而已拉！<br>而这两个方法简单来说是长这样子的：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="comment"># ......</span></div><div class="line">script = <span class="built_in">require</span>(path)</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">typeof</span> script <span class="keyword">is</span> <span class="string">'function'</span></div><div class="line">  script @</div><div class="line"><span class="keyword">else</span></div><div class="line">  @logger.warning <span class="string">"Expected <span class="subst">#&#123;full&#125;</span> to assign a function to module.exports, got <span class="subst">#&#123;<span class="keyword">typeof</span> script&#125;</span>"</span></div><div class="line"><span class="comment"># ......</span></div></pre></td></tr></table></figure>
<p>它们只是获取脚本路径，然后去 <code>require</code> 脚本，最后把 <code>this</code>(即 robot 对象) 作为参数传给 script 拉！<br>所以明白为什么我们之前说脚本要写成下面这样子了吧！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// coffee</div><div class="line">module.exports = (robot) -&gt;</div><div class="line"></div><div class="line">// js</div><div class="line">module.exports = function(robot) &#123;&#125;</div></pre></td></tr></table></figure>
<p>知道了最基本的脚本写法之后，我们就可以愉快的编写属于我们的 hubot script 拉！</p>
<h2 id="接受消息"><a href="#接受消息" class="headerlink" title="接受消息"></a>接受消息</h2><p>作为一个聊天机器人，hubot 最基本的功能是要监听特定的「输入」。<br>Hubot 给我们提供了三个不同层次的方法来监听输入：<code>robot.hear</code>、<code>robot.respond</code> 和 <code>robot.listen</code>。</p>
<h3 id="robot-hear"><a href="#robot-hear" class="headerlink" title="robot.hear"></a>robot.hear</h3><p>监听任何匹配的「输入」。<br>即在聊天过程中，只要匹配到特定的消息，就会触发回调函数。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line"></div><div class="line">  <span class="comment"># 匹配任何带有 hello 的消息，如</span></div><div class="line">  <span class="comment"># hello</span></div><div class="line">  <span class="comment"># hellooooo</span></div><div class="line">  <span class="comment"># haha helloooooo</span></div><div class="line">  robot.hear <span class="regexp">/hello/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    <span class="comment"># do what you want</span></div></pre></td></tr></table></figure>
<h3 id="robot-respond"><a href="#robot-respond" class="headerlink" title="robot.respond"></a>robot.respond</h3><p>监听对 hubot 说的「输入」。<br>即在聊天过程中，前面带有 hubot/hubot:/@hubot 的消息才会被匹配，然后触发回调函数。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line"></div><div class="line">  <span class="comment"># 匹配对 hubot 说的 hi，如</span></div><div class="line">  <span class="comment"># hubot hi</span></div><div class="line">  <span class="comment"># @hubot hihihi~</span></div><div class="line">  <span class="comment"># hubot: hihihi!</span></div><div class="line">  robot.respond <span class="regexp">/hi/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    <span class="comment"># do what you want</span></div></pre></td></tr></table></figure>
<h3 id="robot-listen"><a href="#robot-listen" class="headerlink" title="robot.listen"></a>robot.listen</h3><p>自由度最高的监听器，传入一个函数（Match Function）对消息进行匹配。<br>该函数返回 <code>true</code> 时回调函数会被执行。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line"></div><div class="line">  <span class="comment"># 根据「消息」对象做处理</span></div><div class="line">  robot.listen(</div><div class="line">    <span class="function"><span class="params">(message)</span> -&gt;</span> message.user.name <span class="keyword">is</span> <span class="string">"Scarlex"</span>,</div><div class="line">    <span class="function"><span class="params">(res)</span> -&gt;</span> <span class="comment"># do what you want</span></div><div class="line">  )</div></pre></td></tr></table></figure>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>聊天机器人除了接收「输入」之外，还需要对消息做出「响应」。<br>有没有留意到上面接收消息中的回调函数都有一个 <code>res</code> 呢？<br>你猜对拉！和 Node.js 中的 <code>res</code> 用来响应 <code>req</code> 一样，这里的 <code>res</code> 也是是用来响应「输入」的。<br>其中比较常用的两个方法是 <code>res.send</code> 和 <code>res.reply</code>。</p>
<h3 id="res-send"><a href="#res-send" class="headerlink" title="res.send"></a>res.send</h3><p>这个方法和 <code>robot.hear</code> 相反，会直接把消息发送到聊天室。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line">  <span class="comment"># 匹配所有 hi 相关的输入，然后发送 hello 到聊天室</span></div><div class="line">  robot.hear <span class="regexp">/hi/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    res.send <span class="string">'hello'</span></div></pre></td></tr></table></figure>
<h3 id="res-reply"><a href="#res-reply" class="headerlink" title="res.reply"></a>res.reply</h3><p>这个方法和 <code>robot.respond</code> 相反，谁对 hubot 聊天就会回复谁。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line">  <span class="comment"># 匹配所有对 hubot 说的 hi，然后回复对 hubot 说话的用户，如</span></div><div class="line">  <span class="comment"># 输入 @hubot hi</span></div><div class="line">  <span class="comment"># 输出 @scarlex hello</span></div><div class="line">  robot.respond <span class="regexp">/hi/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    res.reply <span class="string">'hello'</span></div></pre></td></tr></table></figure>
<h3 id="res-match"><a href="#res-match" class="headerlink" title="res.match"></a>res.match</h3><p>只有上面两个方法是远远不够的，因为上面两个方法并不能对「输入」做任何处理。<br>不知道童鞋们有没有发现，我们其实是用正则表达式来匹配输入的，而正则表达式刚好可以用来做匹配某些关键字！<br>当匹配到关键字之后，我们从哪里可以提取到这些关键字呢？<br>答案就是 <code>res.match</code> 拉！</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line">module.exports = (robot) -&gt;</div><div class="line">  # 用 res.match 来获取正则表达式匹配的结果，如</div><div class="line">  # 输入 open the first door</div><div class="line">  # 输出 opening the first door</div><div class="line">  robot.hear /open the (.*) door/i, (res) -&gt;</div><div class="line">    res.send &quot;opening the #&#123;res.match[1]&#125; door&quot;</div></pre></td></tr></table></figure>
<h2 id="发出-http-请求"><a href="#发出-http-请求" class="headerlink" title="发出 http 请求"></a>发出 http 请求</h2><p>只是匹配消息再回复太简单拉！其实我们可以通过 hubot 发出 http 请求来做出更多的事情！<br>Hubot 自带一个 <a href="https://github.com/technoweenie/node-scoped-http-client" target="_blank" rel="external">node-scoped-http-client</a> 来发 http 请求。<br>用法如下：</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line">robot</div><div class="line">  .http(<span class="string">'https://github.com'</span>)</div><div class="line">  .get() (err, response, body) -&gt;</div><div class="line">    <span class="comment"># do what you want</span></div></pre></td></tr></table></figure>
<p>初看会觉得很奇怪，其实这只是一个高阶函数而已，对应的 javascript 是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">robot</div><div class="line">  .http(<span class="string">'https://github.com'</span>)</div><div class="line">  .get()(<span class="function"><span class="keyword">function</span>(<span class="params">err, response, body</span>) </span>&#123;</div><div class="line">    <span class="comment">// do what you want</span></div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p>事实上，由于我们是在 Node.js 环境下运行 hubot 的， 我们可以用任何 http client 库来实现这个需求，如著名的 <a href="https://github.com/request/request" target="_blank" rel="external">request</a> 库。<br>我们要做的只是运行 <code>npm install request --save</code> 再 <code>require</code> 进来就可以了。</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line">request = <span class="built_in">require</span> <span class="string">'request'</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line">  robot.hear <span class="regexp">/get github page/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    request.get <span class="string">'https://github.com'</span>, <span class="function"><span class="params">(err, response, body)</span> -&gt;</span></div><div class="line">      res.send response.statusCode</div></pre></td></tr></table></figure>
<p>我在这里只演示了 GET 请求，其他类型的请求相信也难不倒大家拉！遇到什么问题去翻翻类库的文档就好拉！</p>
<p>需要提醒一点，在发出 http 请求的时候，不要搞错了 hubot 的 <code>res</code> 对象和 request 的 <code>res</code> 对象哦！</p>
<h2 id="响应-http-请求"><a href="#响应-http-请求" class="headerlink" title="响应 http 请求"></a>响应 http 请求</h2><p>Hubot 内置了一个 <a href="https://github.com/expressjs/express" target="_blank" rel="external">express</a> 来响应 http 请求。<br>它会随 hubot 一并启动，默认端口是 8080，我们可以设置环境变量 <code>EXPRESS_PORT</code> 或 <code>PORT</code> 来改变默认的端口。<br>那么我们怎么才能使用它呢？很简单，只要调用 <code>robot.router</code> 就可以拉！</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line">  <span class="comment"># 打开浏览器，然后输入 http://localhost:8080/hubot/haha</span></div><div class="line">  <span class="comment"># 会看见浏览器显示 ok</span></div><div class="line">  robot.router.get <span class="string">'/hubot/haha'</span>, <span class="function"><span class="params">(req, res)</span> -&gt;</span></div><div class="line">    res.send <span class="string">'ok'</span></div></pre></td></tr></table></figure>
<p>尽情发挥你的想象力去写一些有趣的东西吧！</p>
<p>哦，对了，如果想要禁用这个 express，只要在启动的时候加个 <code>-d</code> 或者 <code>--disable-httpd</code> 就好了。<br>或者设置环境变量 <code>HUBOT_HTTPD</code> 为 <code>false</code> 也可以！<br>即下面的方式都可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ ./bin/hubot -d</div><div class="line">$ ./bin/hubot --disable-httpd</div><div class="line">$ HUBOT_HTTPD=false ./bin/hubot</div></pre></td></tr></table></figure>
<p>当看到控制台输出下面这种警告的时候，就表示 express 被禁止启动拉！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">WARNING A script has tried registering a HTTP route while the HTTP server is disabled with --disabled-httpd.</div></pre></td></tr></table></figure>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>还有一点需要提的是，hubot 自带了一个 EventEmitter，这意味着我们可以通过 <code>robot.emit</code> 和 <code>robot.on</code> 来编写基于事件通讯的代码~</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line"></div><div class="line">  <span class="comment"># 监听输入 event test，然后用 robot.emit 触发 wow 事件</span></div><div class="line">  robot.hear <span class="regexp">/event test/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    args = &#123; id: <span class="string">'12345'</span> &#125;</div><div class="line">    robot.emit <span class="string">'wow'</span>, args</div><div class="line">    res.send <span class="string">'emit wow event with args: '</span> + JSON.stringify args</div><div class="line"></div><div class="line">  <span class="comment"># 用 robot.on 来监听 wow 事件，回调函数中可以获取事件发送过来的参数</span></div><div class="line">  <span class="comment"># 控制台会输出 &#123; id: '12345' &#125;</span></div><div class="line">  robot.<span class="literal">on</span> <span class="string">'wow'</span>, <span class="function"><span class="params">(args)</span> -&gt;</span></div><div class="line">    robot.logger.info args</div></pre></td></tr></table></figure>
<p>这种基于事件通讯的代码非常适合和 webhook 一起使用哦！<br>想象一下，当我们 push 代码到 master 分支的时候，触发一个 webhook，然后 hubot 就帮我们自动部署新版网站，很棒吧！</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>任何代码都不是完美的，它们都有可能报错，当出现错误的时候，我们就需要对错误进行处理拉！<br>在 hubot 里，我们可以用 <code>robot.error</code> 来捕获错误！</p>
<figure class="highlight coffee"><table><tr><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></div><div class="line"></div><div class="line">  <span class="comment"># 输入 error test，会触发一个错误</span></div><div class="line">  robot.hear <span class="regexp">/error test/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></div><div class="line">    JSON.parse([])</div><div class="line"></div><div class="line">  <span class="comment"># 触发错误之后会捕获到错误，然后打印 Unexpected Error!</span></div><div class="line">  </div><div class="line">  robot.error (err, res) -&gt;</div><div class="line">    robot.logger.error <span class="string">"Unexpected Error!"</span></div><div class="line">    <span class="keyword">if</span> res?</div><div class="line">      res.reply <span class="string">"Unexpected Error!!!"</span></div></pre></td></tr></table></figure>
<h2 id="其他有趣而无用的方法"><a href="#其他有趣而无用的方法" class="headerlink" title="其他有趣而无用的方法"></a>其他有趣而无用的方法</h2><p>最后提一下，hubot 自带一些有趣而无用的方法，这些方法很少用，有些需要 adapter 支持才能正常使用。</p>
<h3 id="robot-topic"><a href="#robot-topic" class="headerlink" title="robot.topic"></a>robot.topic</h3><h3 id="robot-enter"><a href="#robot-enter" class="headerlink" title="robot.enter"></a>robot.enter</h3><h3 id="robot-leave"><a href="#robot-leave" class="headerlink" title="robot.leave"></a>robot.leave</h3><h3 id="res-random"><a href="#res-random" class="headerlink" title="res.random"></a>res.random</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hubot.github.com/docs/scripting/" target="_blank" rel="external">https://hubot.github.com/docs/scripting/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;我们在上一篇中介绍了 Hubot 的简单用法，里面提到我们可以为机器人编写脚本来让它根据不同的「输入」来给出不同的「输出」。&lt;br&gt;本文将会
    
    </summary>
    
      <category term="hubot" scheme="http://scarletsky.github.io/categories/hubot/"/>
    
    
      <category term="hubot" scheme="http://scarletsky.github.io/tags/hubot/"/>
    
  </entry>
  
  <entry>
    <title>如何实现无限滚动</title>
    <link href="http://scarletsky.github.io/2016/04/20/how-to-implement-infinite-scroll/"/>
    <id>http://scarletsky.github.io/2016/04/20/how-to-implement-infinite-scroll/</id>
    <published>2016-04-20T09:14:21.000Z</published>
    <updated>2016-04-20T09:18:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>无限滚动对我们来说已经是很常见的功能了，具体表现为当页面滚动到某个位置时就自动加载数据，本文将探讨无限滚动的实现原理以及优化。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们先看看最简单的无限滚动的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  fetch(path).then(<span class="function"><span class="params">res</span> =&gt;</span> doSomeThing(res.data));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, fetchData);</div></pre></td></tr></table></figure>
<p>上面就是无限滚动最简单的例子啦~<br>其实就是监听 <code>window</code> 对象的 <code>scroll</code> 事件，然后再触发获取数据的函数~</p>
<p>然而，上面的例子中还有很多问题，其中最大的问题就是 <strong>获取数据的函数(以后叫 fetch 函数)没有触发条件</strong>， 我们还需要不断优化，才能在生产环境下使用。</p>
<h2 id="添加触发条件"><a href="#添加触发条件" class="headerlink" title="添加触发条件"></a>添加触发条件</h2><p>我们先想想，一般情况下，fetch 函数的触发条件有哪些呢 ？</p>
<ul>
<li>在 fetch 过程中不能重复触发</li>
<li>没有更多数据的时候不能再触发</li>
<li>屏幕距离容器边缘 xxx 的时候触发</li>
</ul>
<p>前两点很好处理，只要加个 <code>isLoading</code> 和 <code>isEnd</code> 的变量就可以了。<br>添加这两个变量之后，我们的代码就变成下面的样子啦：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> isLoading = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> isEnd = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ( !isLoading &amp;&amp; !isEnd ) &#123;</div><div class="line"></div><div class="line">    isLoading = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    fetch(path).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">      isLoading = <span class="literal">false</span>;</div><div class="line">      res.data.length === <span class="number">0</span> &amp;&amp; isEnd = <span class="literal">true</span>;</div><div class="line">      doSomething(res.data);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, fetchData);</div></pre></td></tr></table></figure>
<p>第三点对不熟悉 DOM 的童鞋来说就有点难度了~</p>
<h2 id="计算屏幕与容器边缘的距离"><a href="#计算屏幕与容器边缘的距离" class="headerlink" title="计算屏幕与容器边缘的距离"></a>计算屏幕与容器边缘的距离</h2><p>我们以计算屏幕底部与容器底部边缘为例:</p>
<p>如果有 api 可以直接得到元素底部与屏幕底部的距离就最好啦，可以省去麻烦，但实际上并没有这样的 api。<br>然而，我们可以通过浏览器提供的两个 api，计算出元素底部与屏幕底部之间的距离。</p>
<p>第一个 api 是 <code>window.innerHeight</code>，它返回的是屏幕（viewport）高度。<br>第二个 api 就是 <code>Element.getBoundingClientRect</code> ，这个方法用来计算元素边缘与屏幕（viewport）之间的距离。<br>需要提醒一下，<code>Element.getBoundingClientRect</code> 会得到这么一个类 Object 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">ClientRect &#123;</div><div class="line">  <span class="attr">width</span>: <span class="number">760</span>,   <span class="comment">// 元素宽度</span></div><div class="line">  height: <span class="number">2500</span>, <span class="comment">// 元素高度</span></div><div class="line">  top: <span class="number">-1352</span>,   <span class="comment">// 元素上边缘与屏幕上边缘的距离</span></div><div class="line">  bottom: <span class="number">1239</span>, <span class="comment">// 元素下边缘与屏幕上边缘的距离</span></div><div class="line">  left: <span class="number">760</span>,    <span class="comment">// 元素左边缘与屏幕左边缘的距离</span></div><div class="line">  right: <span class="number">860</span>    <span class="comment">// 元素右边缘与屏幕左边缘的距离</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看看下面这图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     +------&gt; +--------------------------------------------------------+</div><div class="line">     |        |                     document.body                      |</div><div class="line">     |        |                                                        |</div><div class="line">     |        |                                                        |</div><div class="line">body.getBoundingClientRect().top                                       |</div><div class="line">     |        |                                                        |</div><div class="line">     |        |                                                        |</div><div class="line">     |        +--------------------------------------------------------+</div><div class="line">     |        | browser                                              x |</div><div class="line">     +------&gt; +--------------------------------------------------------+ &lt;--+</div><div class="line">     |        | window                                                 |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">window.innerHeight                                                     |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                               body.getBoundingClientRect().bottom</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     |        |                                                        |    |</div><div class="line">     +------&gt; +--------------------------------------------------------+    |</div><div class="line">              |                                                        |    |</div><div class="line">              |                                                        |    |</div><div class="line">              |                                                        |    |</div><div class="line">              |                                                        |    |</div><div class="line">              |                                                        |    |</div><div class="line">              |                                                        |    |</div><div class="line">              +--------------------------------------------------------+ &lt;--+</div></pre></td></tr></table></figure>
<p>有了这两个 api，我们很容易就可以计算出元素底部边缘与屏幕底部边缘的位置啦~</p>
<p>我们再修改下我们的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> isLoading = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> isEnd = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> triggerDistance = <span class="number">200</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> distance = container.getBoundingClientRect().bottom - <span class="built_in">window</span>.innerHeight;</div><div class="line">  <span class="keyword">if</span> ( !isLoading &amp;&amp; !isEnd &amp;&amp; distance &lt; triggerDistance ) &#123;</div><div class="line"></div><div class="line">    isLoading = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    fetch(path).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">      isLoading = <span class="literal">false</span>;</div><div class="line">      res.data.length === <span class="number">0</span> &amp;&amp; isEnd = <span class="literal">true</span>;</div><div class="line">      doSomething(res.data);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, fetchData);</div></pre></td></tr></table></figure>
<p>修改之后，当容器底部与屏幕底部距离小于 200 的时候，才会触发 fetch 函数，这样我们的无限滚动就更加实用啦！</p>
<h2 id="支持-window-以外的元素"><a href="#支持-window-以外的元素" class="headerlink" title="支持 window 以外的元素"></a>支持 window 以外的元素</h2><p>然而，并不是只有 window 才可以滚动，拥有高度的级块元素只要设置了 <code>overflow: scroll</code> 都是可以滚动的。<br>我们需要再修改一下代码来让级块元素也支持无限滚动！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* do something */</span> &#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, fetchData);</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'container'</span>).addEventListener(<span class="string">'scroll'</span>, fetchData);</div></pre></td></tr></table></figure>
<p>很简单吧！只需要为该容器元素添加一个 scroll 的事件监听器就好啦！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;无限滚动对我们来说已经是很常见的功能了，具体表现为当页面滚动到某个位置时就自动加载数据，本文将探讨无限滚动的实现原理以及优化。&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
      <category term="infinite scroll" scheme="http://scarletsky.github.io/tags/infinite-scroll/"/>
    
  </entry>
  
  <entry>
    <title>Hubot 的简单用法</title>
    <link href="http://scarletsky.github.io/2016/04/03/hubot-simple-usage/"/>
    <id>http://scarletsky.github.io/2016/04/03/hubot-simple-usage/</id>
    <published>2016-04-02T16:12:49.000Z</published>
    <updated>2016-04-02T16:16:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hubot 是 Github 的开源聊天机器人，可以用来做一些自动化任务，如部署网站，翻译语言等等。</p>
<p>你可能会说，这些只要写个脚本就可以做到了吧？</p>
<p>确实，但你写完脚本之后还是需要手动运行那些脚本。</p>
<p>你有没想过其实你可以在常用的聊天软件上说 <code>@xxx, 部署新版本的网站</code>，然后机器人就自动登录服务器，然后执行部署脚本，部署成功后告诉你 <code>新版本的网站已经部署成功</code>。</p>
<p>是的，如果你的聊天软件上集成了 Hubot，你就可以轻松地用它来管理一些繁琐的事情啦！</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方推荐我们用 yeoman + hubot 生成器来生成我们的聊天机器人，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install -g yo generator-hubot</div><div class="line">$ mkdir myhubot &amp;&amp; cd myhubot</div><div class="line">$ yo hubot</div></pre></td></tr></table></figure>
<p>回答一些基本的问题后，我们的聊天机器人就生成好啦~</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>我们的聊天机器人的执行文件是 <code>bin/hubot</code>，我们先看看里面写什么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cat ./bin/hubot</div><div class="line"></div><div class="line">#!/bin/sh</div><div class="line"></div><div class="line">set -e</div><div class="line"></div><div class="line">npm install</div><div class="line">export PATH=&quot;node_modules/.bin:node_modules/hubot/node_modules/.bin:$PATH&quot;</div><div class="line"></div><div class="line">exec node_modules/.bin/hubot --name &quot;myhubot&quot; &quot;$@&quot;</div></pre></td></tr></table></figure>
<p>这份执行文件只是先执行 <code>npm install</code>，然后设置环境变量，再执行 <code>node_modules/.bin/hubot</code> 而已，没什么神秘的。</p>
<p>我们试试运行一下这份可执行文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ ./bin/hubot</div><div class="line">myhubot&gt;</div></pre></td></tr></table></figure>
<p>我们看到了一个类似 shell 的东东！试试随便输入一些东西：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">myhubot&gt; hello</div><div class="line">myhubot&gt; world</div><div class="line">myhubot&gt; how are you?</div><div class="line">myhubot&gt; can you hear me?</div></pre></td></tr></table></figure>
<p>我们发现无论我们输入什么，我们的机器人都没有反应，是不是坏掉了？<br>其实并不是这样的，它没反应是因为我们没有对「输入」的处理，如果我们输入一些特定的「输入」，它就会有反应啦！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">myhubot&gt; myhubot ping</div><div class="line">myhubot&gt; PONG</div><div class="line"></div><div class="line">myhubot&gt; myhubot pug me</div><div class="line">myhubot&gt; http://28.media.tumblr.com/tumblr_locinzasB91qzj3syo1_500.jpg</div><div class="line"></div><div class="line">myhubot&gt; myhubot help</div><div class="line">myhubot&gt; myhubot adapter - Reply with the adapter</div><div class="line">myhubot animate me &lt;query&gt; - The same thing as `image me`, except adds a few parameters to try to return an animated GIF instead.</div><div class="line">myhubot echo &lt;text&gt; - Reply back with &lt;text&gt;</div><div class="line">myhubot help - Displays all of the help commands that Hubot knows about.</div><div class="line">myhubot help &lt;query&gt; - Displays all help commands that match &lt;query&gt;.</div><div class="line">myhubot image me &lt;query&gt; - The Original. Queries Google Images for &lt;query&gt; and returns a random top result.</div><div class="line">myhubot map me &lt;query&gt; - Returns a map view of the area returned by `query`.</div><div class="line">myhubot mustache me &lt;url|query&gt; - Adds a mustache to the specified URL or query result.</div><div class="line">myhubot ping - Reply with pong</div><div class="line">myhubot pug bomb N - get N pugs</div><div class="line">myhubot pug me - Receive a pug</div><div class="line">myhubot the rules - Make sure hubot still knows the rules.</div><div class="line">myhubot time - Reply with current time</div><div class="line">myhubot translate me &lt;phrase&gt; - Searches for a translation for the &lt;phrase&gt; and then prints that bad boy out.</div><div class="line">myhubot translate me from &lt;source&gt; into &lt;target&gt; &lt;phrase&gt; - Translates &lt;phrase&gt; from &lt;source&gt; into &lt;target&gt;. Both &lt;source&gt; and &lt;target&gt; are optional</div><div class="line">ship it - Display a motivation squirrel</div></pre></td></tr></table></figure>
<p>看到了吧！如果我们输入了特定的「输入」，机器人就会有反应啦！</p>
<p>当我们输入 <code>myhubot help</code> 的时候，返回的东东其实就是预定义的「输入」，这些预定义的「输入」只在 shell adapter 下有效哦！</p>
<h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><p>什么是 shell adapter ？ 我们运行 <code>./bin/hubot</code> 时默认的 adapter 就是 shell adapter。</p>
<p>什么是 adapter ？ 所谓的 adapter 其实是一些让机器人接收输入的接口。 </p>
<p>刚才提到，shell adapter 是默认情况下的 adapter，主要是用来测试 adapter 是否生效。说白了，其实就是没什么用！</p>
<p>觉得很坑爹是吧？说好的让我们的聊天软件整合我们的机器人呢？</p>
<p>实际上社区已经为我们提供了各种各样的 adapter，我们只要下载就可以用啦！具体请看看 <a href="https://hubot.github.com/docs/adapters/" target="_blank" rel="external">https://hubot.github.com/docs/adapters/</a></p>
<p>那么我们如何指定用某个 adapter 呢？很简单啦，只要启动机器人的时候带上 <code>-a</code> 参数就好了。<br>譬如如果我们想让机器人整合到 telegram，我们只要执行下面的命令就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install --save hubot-telegram</div><div class="line">$ ./bin/hubot -a telegram</div></pre></td></tr></table></figure>
<p>当然我们还需要设置一下，这些设置会根据不同的 adapter 而有所不同，具体请看对应的文档！</p>
<p>如果你所用的聊天软件并不在社区的支持列表中，又想把整合 Hubot 的话，可以自己写 adapter，文档在这里：<a href="https://hubot.github.com/docs/adapters/development/" target="_blank" rel="external">https://hubot.github.com/docs/adapters/development/</a></p>
<h2 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h2><p>我们一直说 Hubot 是聊天机器人，机器人最基本的是根据不同的「输入」给出不同的「输出」。<br>在 Hubot 应该怎么处理不同「输入」，给出不同的「输出」呢？<br>答案就是用 Scripts 啦！</p>
<p>有没有发现我们机器人的目录下有个 <code>scripts/</code> 文件夹？我们可以在这个文件夹下添加各种脚本文件，根据不同的「输入」给出不同的「输出」。<br>在我们启动 Hubot 的时候，它会加载 <code>scripts/</code> 文件夹下的脚本，赋予 Hubot 强大的交互能力！</p>
<p>需要注意的是，<code>scripts/</code> 下的脚本必须是 <code>.coffee</code> 或者 <code>.js</code> 格式的，而且必须暴露一个接受 robot 参数的函数！<br>我们还是先打开 <code>scripts/example.coffee</code> 看看吧！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// coffee</span></div><div class="line"><span class="built_in">module</span>.exports = (robot) -&gt;</div><div class="line"></div><div class="line"><span class="comment">// js</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">robot</span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>在这个函数里面，我们可以利用 <code>robot.hear</code>、<code>robot.response</code>、<code>robot.send</code>、<code>robot.reply</code> 等 api 为不同的「输入」给出不同的「输出」！<br>我们还可以用 <code>robot.http(url).get()</code> 等方法来发出 http 请求！这样我们的机器人就可以有更强大的交互能力了！</p>
<p>想知道更多 api 的用法的话，可以参考文档：<a href="https://hubot.github.com/docs/scripting/" target="_blank" rel="external">https://hubot.github.com/docs/scripting/</a></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>Hubot 真的是一个简单易用的聊天机器人，我们可以把它整合到我们的聊天软件中，让那些简单但繁琐的任务自动化起来，提高我们的工作效率！<br>最后强烈推荐各位同学去读一下 Hubot 的源码，简单易懂，之后会对 Hubot 有更深刻的认识！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hubot.github.com/" target="_blank" rel="external">https://hubot.github.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Hubot 是 Github 的开源聊天机器人，可以用来做一些自动化任务，如部署网站，翻译语言等等。&lt;/p&gt;
&lt;p&gt;你可能会说，这些只要写个
    
    </summary>
    
      <category term="hubot" scheme="http://scarletsky.github.io/categories/hubot/"/>
    
    
      <category term="hubot" scheme="http://scarletsky.github.io/tags/hubot/"/>
    
  </entry>
  
  <entry>
    <title>Lodash 中 assign，extend 和 merge 的区别</title>
    <link href="http://scarletsky.github.io/2016/04/02/assign-vs-extend-vs-merge-in-lodash/"/>
    <id>http://scarletsky.github.io/2016/04/02/assign-vs-extend-vs-merge-in-lodash/</id>
    <published>2016-04-02T02:51:19.000Z</published>
    <updated>2016-04-02T05:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们经常在别人的代码中看见 <code>assign</code>，<code>extend</code>，<code>merge</code> 函数，这三个函数用起来很相似，都是合并源对象的属性到目标对象中。</p>
<p>既然都是合并对象，为什么还分三个不同的函数呢？它们之间到底有什么区别呢？</p>
<h2 id="assign-object-sources"><a href="#assign-object-sources" class="headerlink" title="assign(object, [sources])"></a>assign(object, [sources])</h2><p>我们先看看官方网站上面的定义：</p>
<blockquote>
<p>Assigns own enumerable string keyed properties of source objects to the destination object. Source objects are applied from left to right. Subsequent sources overwrite property assignments of previous sources.</p>
</blockquote>
<p>把源对象(sources)的属性分配到目标对象(object)，源对象会从左往右地调用，后面对象的属性会覆盖前面的。</p>
<p>看看下面的例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">assign(&#123;&#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;);</div><div class="line"><span class="comment">// &#123; a: 1, b: 2 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 后面的 &#123; a: 2 &#125; 把前面的 &#123; a: 1 &#125; 覆盖了</span></div><div class="line">assign(&#123;&#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;);</div><div class="line"><span class="comment">// &#123; a: 2, b: 2 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 观察下面两个例子，如果属性值为 object，后面的值会覆盖前面的值</span></div><div class="line">assign(</div><div class="line">  &#123;&#125;,</div><div class="line">  &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span> &#125; &#125;</div><div class="line">)</div><div class="line"><span class="comment">// &#123; a: 1, b: &#123; c: 2, d: 3 &#125; &#125;</span></div><div class="line"></div><div class="line">assign(</div><div class="line">  &#123;&#125;,</div><div class="line">  &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span> &#125; &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">e</span>: <span class="number">4</span> &#125; &#125;</div><div class="line">)</div><div class="line"><span class="comment">// &#123; a: 1, b: &#123; e: 4 &#125; &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// `assign` 函数会忽略原型链上的属性。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.c = <span class="number">3</span>; &#125;</div><div class="line">Foo.prototype.d = <span class="number">4</span>;</div><div class="line">assign(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="keyword">new</span> Foo());</div><div class="line"><span class="comment">// &#123; a: 1, c: 3 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// `assign` 会修改原来的对象</span></div><div class="line"><span class="keyword">var</span> test = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</div><div class="line">assign(test, &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></div><div class="line"><span class="built_in">console</span>.log(test);      <span class="comment">// &#123; a: 1, b: 2 &#125;</span></div></pre></td></tr></table></figure>
<h2 id="extend-object-sources"><a href="#extend-object-sources" class="headerlink" title="extend(object, [sources])"></a>extend(object, [sources])</h2><p>在 3.x 版本中，<code>extend</code> 是 <code>assign</code> 的别名，它们的作用是一模一样的。<br>在 4.x 版本中，<code>extend</code> 是 <code>assignIn</code> 的别名，和 <code>assign</code> 有点区别。</p>
<p>官方定义如下：</p>
<blockquote>
<p>This method is like _.assign except that it iterates over own and inherited source properties.</p>
</blockquote>
<p>在上面的例子中，我们知道 <code>assign</code> 函数不会把原型链上的属性合并到目标对象，而 <code>extend</code> 或 <code>assignIn</code> 函数则会！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Important !! this is Lodash 4.x !!</span></div><div class="line"></div><div class="line"><span class="comment">// 把源对象原型链上的属性也合并到目标对象上！</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.c = <span class="number">3</span>; &#125;</div><div class="line">Foo.prototype.d = <span class="number">4</span>;</div><div class="line">extend(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="keyword">new</span> Foo());</div><div class="line"><span class="comment">// &#123; a: 1, c: 3, d: 4 &#125;</span></div></pre></td></tr></table></figure>
<h2 id="merge-object-sources"><a href="#merge-object-sources" class="headerlink" title="merge(object, [sources])"></a>merge(object, [sources])</h2><p>我们看看 <code>merge</code> 函数的定义：</p>
<blockquote>
<p>This method is like _.assign except that it recursively merges own and inherited enumerable string keyed properties of source objects into the destination object. Source properties that resolve to undefined are skipped if a destination value exists. Array and plain object properties are merged recursively.Other objects and value types are overridden by assignment. Source objects are applied from left to right. Subsequent sources overwrite property assignments of previous sources.</p>
</blockquote>
<p><code>merge</code> 也和 <code>assign</code> 类似，不同的地方在于 <code>merge</code> 遇到相同属性的时候，如果属性值为纯对象(plain object)或者集合(collection)时，不是用后面的属性值去覆盖前面的属性值，而是会把前后两个属性值合并。<br>如果源对象的属性值为 <code>undefined</code>，则会忽略该属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">assign(</div><div class="line">  &#123;&#125;,</div><div class="line">  &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span>&#125; &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">e</span>: <span class="number">4</span> &#125; &#125;</div><div class="line">)</div><div class="line"><span class="comment">// &#123; a: 1, b: &#123; e: 4 &#125; &#125;</span></div><div class="line">merge(</div><div class="line">  &#123;&#125;,</div><div class="line">  &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span>&#125; &#125;,</div><div class="line">  &#123; <span class="attr">b</span>: &#123; <span class="attr">e</span>: <span class="number">4</span> &#125; &#125;</div><div class="line">)</div><div class="line"><span class="comment">// &#123; a: 1, b: &#123; c: 2, d: 3, e: 4 &#125; &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 合并集合</span></div><div class="line"><span class="keyword">var</span> users = &#123;</div><div class="line">  <span class="string">'data'</span>: [&#123; <span class="string">'user'</span>: <span class="string">'barney'</span> &#125;, &#123; <span class="string">'user'</span>: <span class="string">'fred'</span> &#125;]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> ages = &#123;</div><div class="line">  <span class="string">'data'</span>: [&#123; <span class="string">'age'</span>: <span class="number">36</span> &#125;, &#123; <span class="string">'age'</span>: <span class="number">40</span> &#125;]</div><div class="line">&#125;;</div><div class="line">merge(&#123;&#125;, users, ages)</div><div class="line"><span class="comment">// &#123; data: [ &#123; user: 'barney', age: 36 &#125;, &#123; user: 'fred', age: 40 &#125; ] &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// merge 函数会修改原来的对象！</span></div><div class="line">merge(users, ages)</div><div class="line"><span class="built_in">console</span>.log(users) <span class="comment">// &#123; data: [ &#123; user: 'barney', age: 36 &#125;, &#123; user: 'fred', age: 40 &#125; ]</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h3><ul>
<li>都可以用来合并对象</li>
<li>都会修改原来的对象 (如果原来的对象是作为函数的第一个参数的话)</li>
</ul>
<h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><ul>
<li><p><code>assign</code> 函数不会处理原型链上的属性，也不会合并相同的属性，而是用后面的属性值覆盖前面的属性值</p>
</li>
<li><p><code>extend</code></p>
<ul>
<li>3.x 版本中和 <code>assign</code> 一样</li>
<li>4.x 版本中会合并原型链上的属性</li>
</ul>
</li>
<li><p><code>merge</code> 遇到相同属性名的时候，如果属性值是纯对象或集合的时候，会合并属性值</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://lodash.com/docs" target="_blank" rel="external">https://lodash.com/docs</a><br><a href="http://stackoverflow.com/questions/19965844/lodash-difference-between-extend-assign-and-merge" target="_blank" rel="external">http://stackoverflow.com/questions/19965844/lodash-difference-between-extend-assign-and-merge</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;我们经常在别人的代码中看见 &lt;code&gt;assign&lt;/code&gt;，&lt;code&gt;extend&lt;/code&gt;，&lt;code&gt;merge&lt;/cod
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>type vs data vs newtype in Haskell</title>
    <link href="http://scarletsky.github.io/2016/03/15/type-vs-data-vs-newtype-in-haskell/"/>
    <id>http://scarletsky.github.io/2016/03/15/type-vs-data-vs-newtype-in-haskell/</id>
    <published>2016-03-15T10:09:56.000Z</published>
    <updated>2016-07-16T12:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p><code>type</code> 关键字用来设置类型别名，提高代码可读性。</p>
<p>我们可以类比 shell 里面的 <code>alias</code> 命令，它是用来设置命令别名的。譬如下面的 shell 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">alias</span> aria2-server=<span class="string">"aria2c --conf-path ~/aria2.conf"</span></div></pre></td></tr></table></figure>
<p>我们用 <code>aria2-server</code> 来代替 <code>aria2c --conf-path ~/aria2.conf</code>，它们本质上是一样的，只是一个不同的名字，方便我们输入而已。</p>
<p>Haskell 中的 <code>type</code> 命令也是一样，它用来设置一个 <strong>「已有类型」</strong> 的别名。</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="type">BookId</span> = <span class="type">Int</span></span></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="type">BookSummary</span> = <span class="type">String</span></span></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="type">BookRecord</span> = (<span class="type">BookId</span>, <span class="type">BookSummary</span>)</span></div></pre></td></tr></table></figure>
<p>上面的代码只是为一些 <strong>「已有类型」</strong> 设置一个别名，并没有创建新的数据类型，因此它不能使用 <code>deriving</code> 关键字。</p>
<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p><code>data</code> 关键字用来创建新的数据类型，有「类型构造器」 和 「值构造器」，它们的名字可以是相同的，也可以是不同的。<br>其中，有一个以上「值构造器」的数据类型称为 「代数数据类型（algebraic data type）」。</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- BookInfo 是类型构造器</span></div><div class="line"><span class="comment">-- Book 是值构造器</span></div><div class="line"><span class="comment">-- ghci&gt; Book 1 "Hello" :: BookInfo</span></div><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">BookInfo</span> = <span class="type">Book</span> <span class="type">Int</span> <span class="type">String</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></div><div class="line"></div><div class="line"><span class="comment">-- 左边的 Book 是类型构造器</span></div><div class="line"><span class="comment">-- 右边的 Book 是值构造器</span></div><div class="line"><span class="comment">-- ghci&gt; Book 1 "World" :: Book</span></div><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Book</span> = <span class="type">Book</span> <span class="type">Int</span> <span class="type">String</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></div><div class="line"></div><div class="line"><span class="comment">-- Tree a 是代数数据类型</span></div><div class="line"><span class="comment">-- a 是类型参数，表示任意类型</span></div><div class="line"><span class="comment">-- Empty 和 Node 都是值构造器</span></div><div class="line"><span class="comment">-- ghci&gt; Empty :: Tree a</span></div><div class="line"><span class="comment">-- ghci&gt; Node 1 (Empty) (Empty) :: Num a =&gt; Tree a</span></div><div class="line"><span class="comment">-- ghci&gt; Node "Hello" Empty (Node "World" (Empty) (Empty)) :: Tree [Char]</span></div><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Empty</span> | <span class="type">Node</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></div></pre></td></tr></table></figure>
<p><code>data</code> 支持用 Record Syntax 来创建数据类型，用 Record Syntax 生成数据类型的同时会生成一些 <code>getter</code> 函数。</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123;</span></div><div class="line">    <span class="title">name</span> :: <span class="type">String</span>,</div><div class="line">    <span class="title">age</span> :: <span class="type">Int</span>,</div><div class="line">    <span class="title">height</span> :: <span class="type">Float</span></div><div class="line">&#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</div><div class="line"></div><div class="line"><span class="comment">-- 自动生成下面这些 getter 函数</span></div><div class="line"><span class="comment">-- name :: Person -&gt; String</span></div><div class="line"><span class="comment">-- age :: Person -&gt; Int</span></div><div class="line"><span class="comment">-- height :: Person -&gt; Float</span></div><div class="line"></div><div class="line"><span class="comment">-- 通过如下方式来创建数据</span></div><div class="line"><span class="comment">-- let p = Person &#123; name="John", age=30, height=1.8 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">-- 使用 getter 函数</span></div><div class="line"><span class="comment">-- name p -&gt; "John"</span></div><div class="line"><span class="comment">-- age p -&gt; 30</span></div><div class="line"><span class="comment">-- height p -&gt; 1.8</span></div></pre></td></tr></table></figure>
<h2 id="newtype"><a href="#newtype" class="headerlink" title="newtype"></a>newtype</h2><p><code>newtype</code> 关键字和 <code>data</code> 类似，都是用来创建新的数据类型，但 <code>newtype</code> 的值构造器限制在一个，而 <code>data</code> 没有限制值构造器的数量。<br>另外，<code>newtype</code> 速度比 <code>data</code> 要快。</p>
<p>为什么既然有了 <code>data</code> 还要有 <code>newtype</code> ？ 先看下面这个例子：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line">[(+<span class="number">2</span>), (*<span class="number">3</span>)] &lt;*&gt; [<span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="comment">-- 结果是 [4, 5, 6, 9]</span></div><div class="line"><span class="comment">-- 但我希望的结果是 [4, 9]，该怎样做 ？</span></div></pre></td></tr></table></figure>
<p>在上面的例子中，因为 <code>[]</code> 已经是 <code>Applicative</code> 的实例了，也就是说它已经实现了自己的 <code>&lt;*&gt;</code> 方法了。<br>如果不重新实现 <code>&lt;*&gt;</code> 方法，我们是没有办法得到 <code>[4, 9]</code> 这个结果的。</p>
<p>但怎样才能既不改动原有的 <code>[]</code>，又可以重新实现 <code>&lt;*&gt;</code> 方法呢 ？<br>答案就是用 <code>newtype</code> 把 <code>[]</code> 封装成一个新的类型，然后让这个新的类型成为 <code>Applicative</code> 的实例啦~<br>我们来试试：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">ZipList</span> a = <span class="type">ZipList</span> &#123; <span class="title">getZipList</span> :: [<span class="title">a</span>] &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></div><div class="line"></div><div class="line"><span class="comment">-- 要让 ZipList 成为 Applicative 的实例，</span></div><div class="line"><span class="comment">-- 必须先让 ZipList 成为 Functor 的实例</span></div><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">ZipList</span> <span class="keyword">where</span></span></div><div class="line">    fmap f xs = undefined</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">ZipList</span> <span class="keyword">where</span></div><div class="line">    pure x = undefined</div><div class="line">    <span class="type">ZipList</span> fs &lt;*&gt; <span class="type">ZipList</span> xs = <span class="type">ZipList</span> (zipWith id fs xs)</div><div class="line"></div><div class="line"><span class="comment">-- ghci&gt; getZipList $ ZipList [(+2), (*3)] &lt;*&gt; ZipList [2,3]</span></div><div class="line"><span class="comment">-- ghci&gt; [4, 9]</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>type</code> 用来为一个已有类型声明别名。<br><code>data</code> 用来定义新的数据类型，可以有任意个值构造器。<br><code>newtype</code> 用来封装已有的数据类型，只能有一个值构造器，速度比 <code>data</code> 快。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://learnyoua.haskell.sg/content/zh-cn/ch08/build-our-own-type-and-typeclass.html" target="_blank" rel="external">Build Our Own Type and Typeclss</a><br><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids" target="_blank" rel="external">Functors, Applicative Functors and Monoids</a><br><a href="http://cnhaskell.com/chp/3.html" target="_blank" rel="external">Defining types, streamlining functions</a><br><a href="http://cnhaskell.com/chp/6.html" target="_blank" rel="external">Using typeclasses</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;type&quot;&gt;&lt;a href=&quot;#type&quot; class=&quot;headerlink&quot; title=&quot;type&quot;&gt;&lt;/a&gt;type&lt;/h2&gt;&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 关键字用来设置类型别名，提高代码可读性。&lt;/p&gt;
&lt;p&gt;我们可以类比 shell 里面的
    
    </summary>
    
      <category term="haskell" scheme="http://scarletsky.github.io/categories/haskell/"/>
    
    
      <category term="haskell" scheme="http://scarletsky.github.io/tags/haskell/"/>
    
  </entry>
  
  <entry>
    <title>What is applicative in Haskell ?</title>
    <link href="http://scarletsky.github.io/2016/03/07/what-is-applicative-in-haskell/"/>
    <id>http://scarletsky.github.io/2016/03/07/what-is-applicative-in-haskell/</id>
    <published>2016-03-07T03:52:28.000Z</published>
    <updated>2016-07-16T12:15:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>什么是 <code>Applicative</code> ?</p>
<blockquote>
<p>Applicative 是加强版的 Functor，是一个类型类。</p>
</blockquote>
<p>加强版的 <code>Functor</code> 是什么意思 ?</p>
<blockquote>
<p>还记得 Functor 的限制吗？<br><code>fmap f x</code> 中的 <code>f</code> 只接受一个参数。<br><code>fmap f x</code> 中的 <code>f</code> 不能带有上下文 (换句话说只能是 <code>(+42)</code> 不能是 <code>Just (+42)</code>)。<br>所谓的加强版的 Functor 就没有这些限制。</p>
</blockquote>
<p>这样有什么用 ?</p>
<blockquote>
<p>我们先看看 Applicative 的声明吧:<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">f</span>) =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></div><div class="line">    pure :: a -&gt; f a</div><div class="line">    &lt;*&gt; :: f (a -&gt; b) -&gt; f a -&gt; b</div></pre></td></tr></table></figure></p>
<p>你能从 Applicative 的声明中看出什么吗？</p>
</blockquote>
<p><code>Applicative</code> 是 <code>Functor</code> ?</p>
<blockquote>
<p>是的，所谓加强版的 Functor，它首先就是一个 Functor，外加一些额外的功能嘛。</p>
</blockquote>
<p><code>pure</code> 有什么用 ?</p>
<blockquote>
<p>把一个值变成一个 Applicative Functor 。</p>
</blockquote>
<p><code>&lt;*&gt;</code> 呢 ?</p>
<blockquote>
<p>和 fmap (也就是 &lt;$&gt;) 一起看吧。<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line">&lt;$&gt; ::   (a -&gt; b) -&gt; f a -&gt; f b</div><div class="line">&lt;*&gt; :: f (a -&gt; b) -&gt; f a -&gt; f b</div></pre></td></tr></table></figure></p>
</blockquote>
<p><code>&lt;$&gt;</code> 传进的是普通的函数，而 <code>&lt;*&gt;</code> 传进的是一个包装过的函数 ?</p>
<blockquote>
<p>是的，这就是 Applicative 和 Functor 的区别。</p>
</blockquote>
<p>有没有简单易懂的例子 ?</p>
<blockquote>
<p>先看看下面几个例子吧。<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">ghci</span>&gt; (+<span class="number">33</span>) &lt;$&gt; <span class="type">Just</span> <span class="number">9</span></div><div class="line"><span class="type">Just</span> <span class="number">42</span></div><div class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> (+<span class="number">33</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></div><div class="line"><span class="type">Just</span> <span class="number">42</span></div><div class="line"><span class="title">ghci</span>&gt; pure (+<span class="number">33</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></div><div class="line"><span class="type">Just</span> <span class="number">42</span></div></pre></td></tr></table></figure></p>
<p>能看出什么吗？</p>
</blockquote>
<p>包装过的函数和普通函数一样，都可以接受包装过的值作为参数，并返回正确的结果？</p>
<blockquote>
<p>正确！<br>我们再看看下面两个例子:<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> (+) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">8</span></div><div class="line"><span class="type">Just</span> <span class="number">11</span></div><div class="line"><span class="title">ghci</span>&gt; pure (+) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">8</span></div><div class="line"><span class="type">Just</span> <span class="number">11</span></div></pre></td></tr></table></figure></p>
<p>能看出什么吗 ?</p>
</blockquote>
<p>包装过的函数可以接受多个参数了 ?</p>
<blockquote>
<p>是的！<br>Applicative 就是通过接受一个带有上下文的函数来突破 Functor 的限制的。<br>我们先凭直觉来用一下 Applicative 吧！</p>
</blockquote>
<h2 id="小试"><a href="#小试" class="headerlink" title="小试"></a>小试</h2><p><code>Just (++) &lt;*&gt; Just &quot;Hello&quot; &lt;*&gt; Just &quot; World&quot;</code> 的结果是 ?</p>
<blockquote>
<p>Just “Hello World”</p>
</blockquote>
<p><code>(++) &lt;$&gt; Just &quot;Hello &quot; &lt;*&gt; Just &quot;Haskell~&quot;</code> 的结果是 ?</p>
<blockquote>
<p>Just “Hello Haskell~”</p>
</blockquote>
<p><code>(++) &lt;$&gt; Just 42 &lt;*&gt; Nothing</code> 的结果是 ?</p>
<blockquote>
<p>Nothing</p>
</blockquote>
<p><code>[(*0), (+100), (^2)] &lt;*&gt; [1, 2, 3]</code> 的结果是 ?</p>
<blockquote>
<p>[0,0,0,101,102,103,1,4,9]</p>
</blockquote>
<p>为什么不是 <code>[0, 102, 9]</code> ?</p>
<blockquote>
<p>因为列表是 Applicative 的实例，它实现了自己的 &lt;*&gt; 方法。</p>
</blockquote>
<p>所以其实 <code>Maybe</code> 也是 <code>Applicative</code> 的实例 ?</p>
<blockquote>
<p>是的。</p>
</blockquote>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p><code>Maybe</code> 是怎么实现 <code>&lt;*&gt;</code> 的 ?</p>
<blockquote>
<p>如下所示:<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></div><div class="line">    pure          = <span class="type">Just</span></div><div class="line">    <span class="type">Just</span> f  &lt;*&gt; m = fmap f m</div><div class="line">    <span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span></div></pre></td></tr></table></figure></p>
<p>现在可以试试理解 &lt;*&gt; 是如何应用在 Maybe 中的。</p>
</blockquote>
<p><code>Just (+) &lt;*&gt; Just 3</code> 的结果是 ?</p>
<blockquote>
<p>Just (+3)</p>
</blockquote>
<p>所以 <code>Just (+) &lt;*&gt; Just 3 &lt;*&gt; Just 8</code> 是 <code>Just 11</code> ?</p>
<blockquote>
<p>是的！</p>
</blockquote>
<p>那列表是怎么实现 <code>&lt;*&gt;</code> 的 ?</p>
<blockquote>
<p>如下所示:<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></div><div class="line">    pure x = [x]</div><div class="line">    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</div></pre></td></tr></table></figure></p>
<p>列表是通过「列表解析(List Comprehension)」来实现 <code>&lt;*&gt;</code> 的。<br>其中的 fs 可以看成是一个由函数组成的列表，如 [(+1), (*2), (^3)]<br>整个过程可以看作 <code>concatMap (\f -&gt; map f xs) fs</code> 的另一个写法。</p>
</blockquote>
<p>还有哪些是 <code>Applicative</code> 的实例 ?</p>
<blockquote>
<p><code>IO</code>, <code>(-&gt;) r</code></p>
</blockquote>
<p><code>IO</code> 怎么实现 <code>&lt;*&gt;</code> ?</p>
<blockquote>
<p>看看下面的代码:<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">IO</span> <span class="keyword">where</span></span></div><div class="line">    pure = return</div><div class="line">    a &lt;*&gt; b = <span class="keyword">do</span></div><div class="line">        f &lt;- a</div><div class="line">        x &lt;- b</div><div class="line">        return (f x)</div></pre></td></tr></table></figure></p>
</blockquote>
<p>不太懂，有没有具体的例子 ?</p>
<blockquote>
<p>下面有个简单易懂的例子:<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">myAction</span> :: <span class="type">IO</span> <span class="type">String</span></div><div class="line"><span class="title">myAction</span> = <span class="keyword">do</span></div><div class="line">    a &lt;- getLine</div><div class="line">    b &lt;- getLine</div><div class="line">    return $ a ++ b</div></pre></td></tr></table></figure></p>
<p>其实我们可以可以写成下面这样:<br><code>myAction = (++) &lt;$&gt; getLine &lt;*&gt; getLine</code></p>
</blockquote>
<p>那 <code>(-&gt;) r</code> 又是什么 ?</p>
<blockquote>
<p><code>(-&gt;) r</code> 其实是函数，如果语法允许的话，我们写成 <code>r -&gt;</code> 也可以，但是语法只允许 <code>(-&gt;) r</code> 这种写法。</p>
</blockquote>
<p><code>(-&gt;) r</code> 是怎么实现 <code>&lt;*&gt;</code> 的 ?</p>
<blockquote>
<p>看看下面的代码:<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) r) <span class="keyword">where</span></span></div><div class="line">    pure x = (\_ -&gt; x)</div><div class="line">    f &lt;*&gt; g = \x -&gt; f x (g x)</div></pre></td></tr></table></figure></p>
</blockquote>
<p><code>(-&gt;) r</code> 的 <code>&lt;*&gt;</code> 实现不是太好理解。</p>
<blockquote>
<p>确实不太好理解，它的意思是给 <code>&lt;*&gt;</code> 两个函数，然后生成一个新的函数。</p>
</blockquote>
<p>有具体例子吗？</p>
<blockquote>
<p>这里要先留意一下 pure 的实现:<br><code>pure x = (\_ -&gt; x)</code><br>它会包装传进的函数，返回一个新的函数。这个新函数会无视第一个传进的参数，然后返回原来的函数。 </p>
</blockquote>
<p>看起来很绕，可以给一些例子吗 ?</p>
<blockquote>
<p>是的，直接看例子会好理解一点:<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">ghci</span>&gt; :t pure (+<span class="number">3</span>)</div><div class="line"><span class="title">pure</span> (+<span class="number">3</span>) :: f (a -&gt; a)</div><div class="line"></div><div class="line"><span class="title">ghci</span>&gt; :t pure (+<span class="number">3</span>) <span class="number">2</span></div><div class="line"><span class="title">pure</span> (+<span class="number">3</span>) <span class="number">2</span> :: a -&gt; a</div><div class="line"></div><div class="line"><span class="title">ghci</span>&gt; pure (+<span class="number">3</span>) <span class="number">2</span> <span class="number">4</span></div><div class="line"><span class="number">7</span></div></pre></td></tr></table></figure></p>
<p>看到了吗 ?<br><code>pure (+3)</code> 返回的是 <code>(\_ -&gt; (+3))</code>。<br><code>pure (+3) 2</code> 返回的是 <code>(+3)</code>。<br><code>pure (+3) 2 4</code> 其实是 <code>(+3) 4</code> 的结果。</p>
</blockquote>
<p>OK，我已经了解 <code>pure</code> 是如何处理函数的了。</p>
<blockquote>
<p>好，接下来我们看 <code>&lt;*&gt;</code> 的实现。<br>看看下面的例子，我们按照定义一步一步来~<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 例子1</span></div><div class="line">    pure (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>)</div><div class="line"><span class="comment">-- 展开 pure (+3)</span></div><div class="line">= (\_ -&gt; (+<span class="number">3</span>)) &lt;*&gt; (*<span class="number">100</span>)</div><div class="line"><span class="comment">-- 展开 &lt;*&gt;</span></div><div class="line">= \x -&gt; (\_ -&gt; (+<span class="number">3</span>)) x (*<span class="number">100</span> x)</div><div class="line"><span class="comment">-- 当 x = 5 时</span></div><div class="line">= \<span class="number">5</span> -&gt; (\_ -&gt; (+<span class="number">3</span>)) <span class="number">5</span> (*<span class="number">100</span> <span class="number">5</span>)</div><div class="line"><span class="comment">-- 传进 5 之后的返回值如下</span></div><div class="line">= (\_ -&gt; (+<span class="number">3</span>)) <span class="number">5</span> <span class="number">500</span></div><div class="line"><span class="comment">-- 无论第一个参数是什么，它都是返回 (+3)</span></div><div class="line">= (+<span class="number">3</span>) <span class="number">500</span></div><div class="line">= <span class="number">503</span></div><div class="line"></div><div class="line"><span class="comment">-- 例子2</span></div><div class="line">    (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>)</div><div class="line"><span class="comment">-- 展开 &lt;$&gt;</span></div><div class="line">= (+) . (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>)</div><div class="line"><span class="comment">-- 展开 &lt;*&gt;</span></div><div class="line">= \x -&gt; (+) . (+<span class="number">3</span>) x (*<span class="number">100</span> x)</div><div class="line"><span class="comment">-- 当 x = 5 时</span></div><div class="line">= \<span class="number">5</span> -&gt; (+) . (+<span class="number">3</span>) <span class="number">5</span> (*<span class="number">100</span> <span class="number">5</span>)</div><div class="line"><span class="comment">-- 返回值</span></div><div class="line">= (+) . (+<span class="number">3</span>) <span class="number">5</span> <span class="number">500</span></div><div class="line">= (<span class="number">8</span>+) <span class="number">500</span></div><div class="line">= <span class="number">508</span></div><div class="line"></div><div class="line"><span class="comment">-- 例子3</span></div><div class="line">    (\x y z -&gt; [x,y,z]) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">2</span>) &lt;*&gt; (/<span class="number">2</span>)</div><div class="line"><span class="comment">-- 先假设 (\x y z -&gt; [x,y,z]) 为 f</span></div><div class="line">= f &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">2</span>) &lt;*&gt; (/<span class="number">2</span>)</div><div class="line"><span class="comment">-- 展开 &lt;$&gt;</span></div><div class="line">= f . (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">2</span>) &lt;*&gt; (/<span class="number">2</span>)</div><div class="line"><span class="comment">-- 展开第一个 &lt;*&gt;</span></div><div class="line">= \x -&gt; (f . (+<span class="number">3</span>)) x (*<span class="number">2</span> x) &lt;*&gt; (/<span class="number">2</span>)</div><div class="line"><span class="comment">-- 展开第二个 &lt;*&gt;</span></div><div class="line">= \y -&gt; (\x -&gt; (f . (+<span class="number">3</span>)) x (*<span class="number">2</span> x)) y (/<span class="number">2</span> y)</div><div class="line"><span class="comment">-- 观察 (\x -&gt; (f . (+3)) x (*2 x)) y</span></div><div class="line"><span class="comment">-- 把 y 传入函数中可以得到</span></div><div class="line">= \y -&gt; (f . (+<span class="number">3</span>)) y (*<span class="number">2</span> y) (/<span class="number">2</span> y)</div><div class="line">= \y -&gt; f (+<span class="number">3</span> y) (*<span class="number">2</span> y) (/<span class="number">2</span> y)</div><div class="line"><span class="comment">-- 当传入 5 作为参数时</span></div><div class="line">= f (+<span class="number">3</span> <span class="number">5</span>) (*<span class="number">2</span> <span class="number">5</span>) (/<span class="number">2</span> <span class="number">5</span>)</div><div class="line">= f <span class="number">8</span> <span class="number">10</span> <span class="number">2.5</span></div><div class="line"><span class="comment">-- 把 f 换回 (\x y z -&gt; [x,y,z])</span></div><div class="line">= [<span class="number">8.0</span>,<span class="number">10.0</span>,<span class="number">2.5</span>]</div></pre></td></tr></table></figure></p>
<p>很有趣吧 !</p>
</blockquote>
<p>每次都要展开 <code>&lt;*&gt;</code> 很麻烦啊 ?</p>
<blockquote>
<p>从刚才的例子中，你应该可以发现，我们从直觉上就可以知道计算过程。<br>试试化简一下 <code>f &lt;$&gt; g &lt;*&gt; h</code> ?</p>
</blockquote>
<p><code>f &lt;$&gt; g &lt;*&gt; h</code> = <code>(\x -&gt; f (g x) (h x))</code>。</p>
<blockquote>
<p>正确，再把 5 传入看看 ?</p>
</blockquote>
<p><code>f &lt;$&gt; g &lt;*&gt; h $ 5</code> = <code>f (g 5) (h 5)</code>。</p>
<blockquote>
<p>假设 f 是一个需要两个参数的函数的话，就能返回计算结果了 !</p>
</blockquote>
<p>所以其实我们可以把 <code>f &lt;$&gt; g &lt;*&gt; h</code> 看成是把 <code>g</code> 和 <code>h</code> 的结果传给 <code>f</code> ?</p>
<blockquote>
<p>是的，我们从直觉上就可以知道计算过程，很有趣吧 !<br>顺便说下, 像 <code>f &lt;$&gt; g &lt;*&gt; h</code> 这样的用法叫做 Applicative Style 哦 !</p>
</blockquote>
<p><code>Applicative</code> 有没有和 <code>Functor</code> 一样需要遵守的规则 ?</p>
<blockquote>
<p>有的！其中最重要的规则是:<br>必须保证 <code>pure f &lt;*&gt; x = fmap f x</code>。</p>
</blockquote>
<p>我应该怎么理解这个规则 ?</p>
<blockquote>
<p>我们说 <code>Applicative</code> 是加强版的 <code>Functor</code>，它可以应用一个带有上下文的函数到 <code>Functor</code> 上。<br>我们看看之前提到的 <code>Applicative</code> 实例 :<br>对于 <code>Maybe</code> :<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line">  pure f &lt;*&gt; x</div><div class="line">= <span class="type">Just</span> f &lt;*&gt; x</div><div class="line">= fmap f x</div></pre></td></tr></table></figure></p>
<p>对于 <code>List</code> :<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line">  pure f &lt;*&gt; x</div><div class="line">= [f] &lt;*&gt; x</div><div class="line">= [f x' | x' &lt;- x]</div><div class="line">= map f x</div><div class="line">= fmap f x</div></pre></td></tr></table></figure></p>
<p>对于 <code>IO</code> :<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line">  pure f &lt;*&gt; x</div><div class="line">= return f &lt;*&gt; x</div><div class="line">= return (f x)</div><div class="line">= fmap f x</div></pre></td></tr></table></figure></p>
<p>对于 <code>(-&gt;) r</code> :<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line">  pure f &lt;*&gt; x</div><div class="line">= (\_ -&gt; f) &lt;*&gt; x</div><div class="line">= (\y -&gt; (\_ -&gt; f) y (x y))</div><div class="line">= (\y -&gt; f (x y))</div><div class="line">= (\y -&gt; (f . x) y)</div><div class="line">= f . x</div><div class="line">= fmap f x</div></pre></td></tr></table></figure></p>
<p>看到了吧 ! 我们上面提到的 <code>Applicative</code> 的实例全部都满足 <code>pure f &lt;*&gt; x = fmap f x</code> 哦 !</p>
</blockquote>
<p>还有其他需要遵守的规则吗 ?</p>
<blockquote>
<p>有的，分别如下:</p>
<ul>
<li><code>pure id &lt;*&gt; v = v</code></li>
<li><code>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></li>
<li><code>pure f &lt;*&gt; pure x = pure (f x)</code></li>
<li><code>u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</code><br>这些规则都是可以被证明的，你可以试一试。</li>
</ul>
</blockquote>
<p>还有什么我需要知道的吗 ?</p>
<blockquote>
<p>忘了说，<code>Applicative</code> 需要导入才可以用，它位于 <code>Control.Applicative</code> 下。<br>想用的时候记得先写 <code>import Control.Applicative</code> 哦 !</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Applicative</code> 是加强版的 <code>Functor</code>。</li>
<li><code>Applicative</code> 的实例可以使用 <code>pure</code> 和 <code>&lt;*&gt;</code>。</li>
<li>我们可以用 <code>&lt;$&gt;</code> 和 <code>&lt;*&gt;</code> 将一个普通函数应用到任意数量的 <code>Applicative Functor</code> 上。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids" target="_blank" rel="external">Functors, Applicative Functors and Monoids</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初探&quot;&gt;&lt;a href=&quot;#初探&quot; class=&quot;headerlink&quot; title=&quot;初探&quot;&gt;&lt;/a&gt;初探&lt;/h2&gt;&lt;p&gt;什么是 &lt;code&gt;Applicative&lt;/code&gt; ?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Applicative 是加强版的 F
    
    </summary>
    
      <category term="haskell" scheme="http://scarletsky.github.io/categories/haskell/"/>
    
    
      <category term="haskell" scheme="http://scarletsky.github.io/tags/haskell/"/>
    
      <category term="applicative" scheme="http://scarletsky.github.io/tags/applicative/"/>
    
  </entry>
  
  <entry>
    <title>FlexibleInstances 和 TypeSynonymInstances 编译指令的区别</title>
    <link href="http://scarletsky.github.io/2016/02/28/flexible-instances-vs-type-synonym-instances-in-haskell/"/>
    <id>http://scarletsky.github.io/2016/02/28/flexible-instances-vs-type-synonym-instances-in-haskell/</id>
    <published>2016-02-28T14:31:21.000Z</published>
    <updated>2016-02-29T04:22:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FlexibleInstances"><a href="#FlexibleInstances" class="headerlink" title="FlexibleInstances"></a>FlexibleInstances</h2><p>先看看下面这个简单的例子：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- Learning.hs</span></div><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vector</span> a = <span class="type">Vector</span> a a <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">class</span> <span class="type">MyClass</span> a <span class="keyword">where</span></div><div class="line">    myFun :: a -&gt; a</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">MyClass</span> (<span class="type">Vector</span> <span class="title">a</span>) <span class="keyword">where</span></div><div class="line">    myFun = id</div></pre></td></tr></table></figure>
<p>这样的定义看起来是没有问题的，因为不需要任何编译指令就能通过编译了。<br>我们可以运行看看：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">ghci</span>&gt; :l <span class="type">Learning</span>.hs</div><div class="line">[<span class="number">1</span> <span class="keyword">of</span> <span class="number">1</span>] <span class="type">Compiling</span> <span class="type">Main</span>             ( <span class="type">Test</span>.hs, interpreted )</div><div class="line"><span class="type">Ok</span>, modules loaded: <span class="type">Main</span>.</div><div class="line"><span class="title">ghci</span>&gt; myFun (<span class="type">Vector</span> <span class="number">1</span> <span class="number">2</span>)</div><div class="line"><span class="type">Vector</span> <span class="number">1</span> <span class="number">2</span></div><div class="line"><span class="title">ghci</span>&gt; myFun (<span class="type">Vector</span> <span class="number">1</span> <span class="number">2</span>) :: <span class="type">Vector</span> <span class="type">Int</span></div><div class="line"><span class="type">Vector</span> <span class="number">1</span> <span class="number">2</span></div><div class="line"><span class="title">ghci</span>&gt; myFun (<span class="type">Vector</span> <span class="number">1</span> <span class="number">2</span>) :: <span class="type">Vector</span> <span class="type">Double</span></div><div class="line"><span class="type">Vector</span> <span class="number">1.0</span> <span class="number">2.0</span></div></pre></td></tr></table></figure>
<p>但如果我们需要为 <code>Vector a</code> 不同的类型参数实现不同的 <code>myFun</code> 的话呢？</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MyClass</span> (<span class="type">Vector</span> <span class="type">Int</span>) <span class="keyword">where</span></span></div><div class="line">    myFun = undefined</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">MyClass</span> (<span class="type">Vector</span> <span class="type">Double</span>) <span class="keyword">where</span></div><div class="line">    myFun = undefined</div></pre></td></tr></table></figure>
<p>我们再看看编译时会发生什么？</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">ghci</span>&gt; :r</div><div class="line">[<span class="number">1</span> <span class="keyword">of</span> <span class="number">1</span>] <span class="type">Compiling</span> <span class="type">Main</span>             ( <span class="type">Learning</span>.hs, interpreted )</div><div class="line"></div><div class="line"><span class="type">Learning</span>.hs:<span class="number">10</span>:<span class="number">10</span>:</div><div class="line">    <span class="type">Illegal</span> <span class="keyword">instance</span> declaration for ‘<span class="type">MyClass</span> (<span class="type">Vector</span> <span class="type">Int</span>)’</div><div class="line">          (<span class="type">All</span> <span class="keyword">instance</span> types must be <span class="keyword">of</span> the form (<span class="type">T</span> a1 ... an)</div><div class="line">           <span class="keyword">where</span> a1 ... an are *distinct <span class="class"><span class="keyword">type</span> variables*,</span></div><div class="line">           and each <span class="class"><span class="keyword">type</span> variable appears at most once in the instance head.</span></div><div class="line">           <span class="type">Use</span> <span class="type">FlexibleInstances</span> <span class="keyword">if</span> you want to disable this.)</div><div class="line">    <span class="type">In</span> the <span class="keyword">instance</span> declaration for ‘<span class="type">MyClass</span> (<span class="type">Vector</span> <span class="type">Int</span>)’</div><div class="line"><span class="type">Failed</span>, modules loaded: none.</div></pre></td></tr></table></figure>
<p>编译失败！为什么会编译失败呢？</p>
<p>因为通常情况下，我们不能给多态类型（polymorphic type）的特化版本（specialized version）写类型类实例。<br>在这个例子中，<code>Vector Int</code> 和 <code>Vector Double</code> 就是 <code>Vector a</code> 的特化版本。<br>如果我们需要为这些特化版本写类型类实例的话，我们就需要开启 <code>FlexibleInstances</code> 编译指令来取消这个限制。</p>
<h2 id="TypeSynonymInstances"><a href="#TypeSynonymInstances" class="headerlink" title="TypeSynonymInstances"></a>TypeSynonymInstances</h2><p>理解了上面的 <code>FlexibleInstances</code> 后，<code>TypeSynonymInstances</code> 就容易理解了。</p>
<p>如果我需要为 <code>Vector Int</code> 添加一个别名，然后让这个别名成为 MyClass 类型类的实例，我们就会需要用到 <code>TypeSynonymInstances</code> 编译指令了。</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="type">VectorInt</span> = <span class="type">Vector</span> <span class="type">Int</span></span></div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">MyClass</span> <span class="type">VectorInt</span> <span class="keyword">where</span></div><div class="line">    myFun = undefined</div></pre></td></tr></table></figure>
<p>默认情况下，ghc 编译上面的代码时会报错，原因是 Haskell 98 并不支持这种语法。<br>要让 ghc 成功编译上面的代码，我们就需要开启 <code>TypeSynonymInstances</code> 这个编译指令了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://rwh.readthedocs.org/en/latest/chp/6.html" target="_blank" rel="external">http://rwh.readthedocs.org/en/latest/chp/6.html</a><br><a href="http://book.realworldhaskell.org/read/using-typeclasses.html" target="_blank" rel="external">http://book.realworldhaskell.org/read/using-typeclasses.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;FlexibleInstances&quot;&gt;&lt;a href=&quot;#FlexibleInstances&quot; class=&quot;headerlink&quot; title=&quot;FlexibleInstances&quot;&gt;&lt;/a&gt;FlexibleInstances&lt;/h2&gt;&lt;p&gt;先看看下面这个简单的
    
    </summary>
    
      <category term="haskell" scheme="http://scarletsky.github.io/categories/haskell/"/>
    
    
      <category term="haskell" scheme="http://scarletsky.github.io/tags/haskell/"/>
    
  </entry>
  
  <entry>
    <title>What is functor in Haskell ?</title>
    <link href="http://scarletsky.github.io/2016/02/09/what-is-functor-in-haskell/"/>
    <id>http://scarletsky.github.io/2016/02/09/what-is-functor-in-haskell/</id>
    <published>2016-02-09T14:50:13.000Z</published>
    <updated>2016-03-01T06:52:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Functor-简介"><a href="#Functor-简介" class="headerlink" title="Functor 简介"></a>Functor 简介</h2><p>什么是 Functor ?</p>
<blockquote>
<p>现在你可以认为 Functor 是一种数据类型。</p>
</blockquote>
<p>Functor 有什么用 ?</p>
<blockquote>
<p>我们可以对 Functor 使用 <code>fmap</code>。</p>
</blockquote>
<p><code>fmap</code> 是什么东西 ?</p>
<blockquote>
<p><code>fmap</code> 是一个函数。</p>
</blockquote>
<p><code>fmap</code> 是函数的话，那它的类型签名是什么 ?</p>
<blockquote>
<p><code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>。</p>
</blockquote>
<p>我应该怎么看这个类型签名 ?</p>
<blockquote>
<p>它接受一个函数和一个 Functor 类型作为参数，然后返回另一个 Functor 。</p>
</blockquote>
<p><code>fmap</code> 有什么用 ?</p>
<blockquote>
<p>类似于 <code>map</code><br><code>map (+1) [1,2,3,4,5]  -- 返回 [2,3,4,5,6]</code><br><code>fmap (+1) [1,2,3,4,5] -- 返回 [2,3,4,5,6]</code></p>
</blockquote>
<p>所以列表是 Functor ?</p>
<blockquote>
<p>是的，List 是 Functor。</p>
</blockquote>
<p>为什么列表是 Functor ?</p>
<blockquote>
<p>因为列表实现了 <code>fmap</code>。</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></div><div class="line">  fmap = map</div></pre></td></tr></table></figure>
</blockquote>
<p>实现了 <code>fmap</code> 的数据类型都是 Functor ?</p>
<blockquote>
<p>不一定。</p>
</blockquote>
<p>为什么 ?</p>
<blockquote>
<p>除了要实现 <code>fmap</code> 之外，还需要满足一些条件才能成为 Functor。</p>
</blockquote>
<p>满足什么条件 ?</p>
<blockquote>
<ol>
<li>必须保证 <code>fmap id = id</code>，也就是说 <code>fmap id xs</code> 和 <code>id xs</code> 必须返回相同的值。</li>
<li>必须是可组合的，两个 <code>fmap</code> 组合使用的结果应该和两个函数组合起来再用 <code>fmap</code> 的结果相同。<br>也就是说 <code>fmap f . fmap g</code> 必须等于 <code>fmap (f . g)</code>。</li>
</ol>
</blockquote>
<p>为什么 <code>fmap id = id</code> ?</p>
<blockquote>
<p>因为<br><code>id :: a -&gt; a</code><br><code>fmap id :: T(a) -&gt; T(a)</code><br>令 <code>T(a) = a</code><br>即 <code>fmap id :: a -&gt; a</code><br>所以 <code>fmap id = id</code></p>
</blockquote>
<p>所以条件一是什么意思 ?</p>
<blockquote>
<p>意思是 <code>fmap</code> 只能对值调用 <code>f</code>，不能做额外的事情。</p>
</blockquote>
<p>有具体例子吗 ?</p>
<blockquote>
<p>看看这个经典的自定义数据类型，C表示计数器：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">CMaybe</span> a = <span class="type">CNothing</span> | <span class="type">CJust</span> <span class="type">Int</span> a <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">CMaybe</span> <span class="keyword">where</span></div><div class="line">  fmap f <span class="type">CNothing</span>          = <span class="type">CNothing</span></div><div class="line">  fmap f (<span class="type">CJust</span> counter x) = <span class="type">CJust</span> (counter + <span class="number">1</span>) (f x)</div><div class="line"></div><div class="line"><span class="comment">-- ghci</span></div><div class="line"></div><div class="line"><span class="title">ghci</span>&gt; fmap (++ <span class="string">"ha"</span>) (<span class="type">CJust</span> <span class="number">0</span> <span class="string">"ho"</span>)</div><div class="line"><span class="type">CJust</span> <span class="number">1</span> <span class="string">"hoha"</span></div><div class="line"><span class="title">ghci</span>&gt; fmap (++ <span class="string">"he"</span>) (fmap (++ <span class="string">"ha"</span>) (<span class="type">CJust</span> <span class="number">0</span> <span class="string">"ho"</span>))</div><div class="line"><span class="type">CJust</span> <span class="number">2</span> <span class="string">"hohahe"</span></div><div class="line"><span class="title">ghci</span>&gt; fmap (++ <span class="string">"blah"</span>) <span class="type">CNothing</span></div><div class="line"><span class="type">CNothing</span></div></pre></td></tr></table></figure>
<p>这里的 <code>fmap</code> 除了对值调用 <code>f</code> 之外，还对 <code>counter</code> 加一。</p>
</blockquote>
<p>这有什么问题吗 ?</p>
<blockquote>
<p>再看看 <code>fmap id</code> 和 <code>id</code><br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">ghci</span>&gt; fmap id (<span class="type">CJust</span> <span class="number">0</span> <span class="string">"haha"</span>)</div><div class="line"><span class="type">CJust</span> <span class="number">1</span> <span class="string">"haha"</span></div><div class="line"><span class="title">ghci</span>&gt; id (<span class="type">Cjust</span> <span class="number">0</span> <span class="string">"haha"</span>)</div><div class="line"><span class="type">CJust</span> <span class="number">0</span> <span class="string">"haha"</span></div></pre></td></tr></table></figure></p>
<p>看出问题了吗 ?</p>
</blockquote>
<p><code>fmap id</code> 和 <code>id</code> 返回的结果不相等 ?</p>
<blockquote>
<p>是的，所以即便 <code>CMaybe a</code> 实现了 <code>fmap</code>，但它也不是 Functor。</p>
</blockquote>
<p>为什么 <code>fmap (f . g) = fmap f . fmap g</code> ?</p>
<blockquote>
<p>假设<br><code>f :: a -&gt; b</code>, <code>g :: b -&gt; c</code><br>那么<br><code>f . g :: a -&gt; c</code><br>即<br><code>fmap (f . g) = T(a) -&gt; T(c)</code><br>又因为<br><code>fmap f = T(a) -&gt; T(b)</code>, <code>fmap g = T(b) -&gt; T(c)</code><br>所以<br><code>fmap f . fmap g = T(a) -&gt; T(c)</code><br>即 <code>fmap (f . g) = fmap f . fmap g</code></p>
</blockquote>
<p>条件二有点像乘法分配律。</p>
<blockquote>
<p>是的。<br>乘法分配律是 <code>(a + b) x c = a x c + b x c</code>。<br>而条件二是 <code>fmap (f . g) = fmap f . fmap g</code>。</p>
</blockquote>
<p>条件二有具体例子吗 ?</p>
<blockquote>
<p>可以类比函数，因为函数本身也是 Functor，所以函数会满足<strong>可组合</strong>这个条件。<br>而实际应用中，我们也经常使用到函数组合这个特性。</p>
</blockquote>
<p>实现了 <code>fmap</code> ，同时满足两个条件的数据类型就是 Functor 吗？</p>
<blockquote>
<p>不，还有一个规则，就是该数据类型要有一个类型参数。</p>
</blockquote>
<p>能举个例子吗 ?</p>
<blockquote>
<p>我们已经知道 List 是一个 Functor，先看看 List 的定义：<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> [] a = [] | a : [a]</span></div></pre></td></tr></table></figure></p>
<p>列表有一个类型参数 a，表示一个列表中可以包含相同类型的元素。</p>
</blockquote>
<p>Functor 只能有一个类型参数吗？</p>
<blockquote>
<p>不是，我们可以通过其他方法让多于一个类型参数的数据类型都能成为 Functor 的实例。</p>
</blockquote>
<p>什么手段 ?</p>
<blockquote>
<p>你需要先知道怎么定义一个 Functor。</p>
</blockquote>
<h2 id="自定义-Functor"><a href="#自定义-Functor" class="headerlink" title="自定义 Functor"></a>自定义 Functor</h2><p>我应该怎么自定义 Functor ?</p>
<blockquote>
<p>先定义一个数据类型，再让该类型成为 Functor 的实例。<br><figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">MyFunctor</span> a = <span class="type">Data</span> a <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">MyFunctor</span> <span class="keyword">where</span></div><div class="line">  fmap f (<span class="type">Data</span> x) = <span class="type">Data</span> (f x)</div></pre></td></tr></table></figure></p>
<p>这样，我们定义的 MyFunctor 就是一个 Functor 了。</p>
</blockquote>
<p>刚才提到的让多于一个类型参数的数据类型成为 Functor 实例的方法是？</p>
<blockquote>
<p>利用 Haskell 中不全调用的特性。</p>
</blockquote>
<p>可以给个例子吗？</p>
<blockquote>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">MyFunctor2</span> a b = <span class="type">Data2</span> a b <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Functor</span> (<span class="type">MyFunctor2</span> <span class="title">a</span>) <span class="keyword">where</span></div><div class="line">  fmap f (<span class="type">Data2</span> x y) = <span class="type">Data2</span> x (f y)</div></pre></td></tr></table></figure>
<p>在 Haskell 中，我们可以利用 Haskell 不全调用的特性，把 MyFunctor2 a 当成一个整体，这样就相当于只有 b 一个类型参数了。</p>
</blockquote>
<h2 id="真-·-Functor"><a href="#真-·-Functor" class="headerlink" title="真 · Functor"></a>真 · Functor</h2><p>我从上面看到，Functor 是一个类型类？</p>
<blockquote>
<p>是的。事实上，<strong>Functor 是一个类型类，表示满足一些条件的数据类型。</strong></p>
</blockquote>
<p>满足上面提到的条件？</p>
<blockquote>
<p>是的！</p>
</blockquote>
<p>有哪些常见的 Functor ？</p>
<blockquote>
<p><code>List</code>, <code>Maybe</code>等等。<br>你可以在 ghci 中输入 <code>:i Functor</code> 来查看更多预定义的 Functor。</p>
</blockquote>
<p>这些 Functor 有什么特点？</p>
<blockquote>
<p>它们都带有上下文：即可以表示有值，也可以表示空值。<br>[] 表示空值，[a] 表示有值；<br>Nothing 表示空值，Just a表示有值；</p>
</blockquote>
<p>这样有什么好处吗？</p>
<blockquote>
<p>好处是显然易见的。考虑下下面的伪代码：<br><figure class="highlight py"><table><tr><td class="code"><pre><div class="line">post = Posts.find_by_id(<span class="number">1</span>)</div><div class="line"><span class="keyword">if</span> post</div><div class="line">  <span class="keyword">return</span> post.title</div><div class="line"><span class="keyword">else</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure></p>
<p>为什么这段伪代码需要判断 post 是否为空？因为 post 没有上下文环境，不能表示空值。<br>如果 post 有上下文环境 (也就是 post 可以表示空值)，那么我们的代码就可以直接写成：<br><figure class="highlight py"><table><tr><td class="code"><pre><div class="line">post = Posts.find_by_id(<span class="number">1</span>)</div><div class="line"><span class="keyword">return</span> post.title</div></pre></td></tr></table></figure></p>
<p>因此，如果一个值可以带有上下文环境的话，我们的代码就可以写的非常简洁。</p>
</blockquote>
<p>把刚才的伪代码写成 Haskell 代码 ?</p>
<blockquote>
<p><code>fmap (getPostTitle) (findPosts 1)</code></p>
</blockquote>
<p><code>if else</code> 不见了？</p>
<blockquote>
<p>是的，这里假设 post 是一个 Functor，它可以表示带有空值的情况。所以 <code>if else</code> 就不需要了。</p>
</blockquote>
<p>那 <code>fmap</code> 呢？ 它事实上是什么东西？</p>
<blockquote>
<p><code>fmap</code> 确确实实是一个函数，它知道怎么把传进的函数应用到 Functor 中，并返回一个新的 Functor。</p>
</blockquote>
<p><code>fmap</code> 对 Functor 调用函数的过程发生了什么？</p>
<blockquote>
<p>看下面两张图 (图出自 <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="external">Functors, Applicatives, And Monads In Pictures</a>)：<br><img src="https://cloud.githubusercontent.com/assets/2386165/12949440/c8753e16-d042-11e5-84ff-b47753d65c52.png" alt="fmap_just"><br><img src="https://cloud.githubusercontent.com/assets/2386165/12949441/c87a69b8-d042-11e5-80d6-2ee458e13e37.png" alt="fmap_nothing"><br>实际上，<code>fmap</code> 先取出 Functor 中的值，然后把值传进函数中，再把函数的返回值放回到 Functor 中，最后返回新的 Functor。</p>
</blockquote>
<p>Functor 有什么限制？</p>
<blockquote>
<p><code>fmap f x</code> 中的 <code>f</code> 只接受一个参数。<br><code>fmap f x</code> 中的 <code>f</code> 不能带有上下文 (换句话说只能是 (+42) 不能是 <code>Just (+42)</code>)。</p>
</blockquote>
<p>关于 Functor 的知识，还有什么我是需要知道的 ？</p>
<blockquote>
<p><code>fmap</code> 可以中缀调用，即 <code>f `fmap` xs</code><br><code>&lt;$&gt;</code> 是 <code>fmap</code> 的别名，一般用于中缀调用，即 <code>f &lt;$&gt; xs</code>。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Functor 是类型类，只要满足以下条件的数据类型都可以成为 Functor 的实例：</p>
<ul>
<li>实现 <code>fmap</code>。</li>
<li>保证 <code>fmap id = id</code>。</li>
<li>保证 <code>fmap (f . g) = fmap f . fmap g</code>。</li>
<li>该数据类型必须有一个以上的类型参数。</li>
</ul>
<p>最后，强烈建议看看 <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="external">这篇文章</a>，相当形象生动。</p>
<h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><p><a href="https://github.com/bramblex" target="_blank" rel="external">@bramblex</a> 给出 <code>fmap id = id</code> 和 <code>fmap (f . g) = fmap f . fmap g</code> 的证明过程。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids" target="_blank" rel="external">Functors, Applicative Functors and Monoids</a><br><a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="external">Functors, Applicatives, And Monads In Pictures</a><br><a href="http://cnhaskell.com/chp/10.html#functor" target="_blank" rel="external">Functor 简介</a><br><a href="http://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor" target="_blank" rel="external">http://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Functor-简介&quot;&gt;&lt;a href=&quot;#Functor-简介&quot; class=&quot;headerlink&quot; title=&quot;Functor 简介&quot;&gt;&lt;/a&gt;Functor 简介&lt;/h2&gt;&lt;p&gt;什么是 Functor ?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在你可
    
    </summary>
    
      <category term="haskell" scheme="http://scarletsky.github.io/categories/haskell/"/>
    
    
      <category term="haskell" scheme="http://scarletsky.github.io/tags/haskell/"/>
    
      <category term="functor" scheme="http://scarletsky.github.io/tags/functor/"/>
    
  </entry>
  
  <entry>
    <title>「译」 Haskell 中随机数的使用</title>
    <link href="http://scarletsky.github.io/2016/02/06/random-numbers-in-haskell/"/>
    <id>http://scarletsky.github.io/2016/02/06/random-numbers-in-haskell/</id>
    <published>2016-02-06T09:35:18.000Z</published>
    <updated>2016-07-16T12:15:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>随机数（我指的是伪随机数）是通过显式或隐式的状态来生成的。这意味着在 Haskell 中，随机数的使用（通过 <code>System.Random</code> 库）是伴随着状态的传递的。 </p>
<p>大部分需要获得帮助的人都有命令式编程的背景，因此，我会先用命令式的方式，然后再用函数式的方式来教大家在 Haskell 中使用随机数。</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>我会生成满足以下条件的随机列表：</p>
<ul>
<li>列表长度是 1 到 7 </li>
<li>列表中的每一项都是 0.0 到 1.0 之间的浮点数</li>
</ul>
<h2 id="命令式"><a href="#命令式" class="headerlink" title="命令式"></a>命令式</h2><p>在 IO monad 中有一个全局的生成器，你可以初始化它，然后获取随机数。下面有一些常用的函数：</p>
<h3 id="setStdGen-StdGen-gt-IO"><a href="#setStdGen-StdGen-gt-IO" class="headerlink" title="setStdGen :: StdGen -&gt; IO ()"></a><code>setStdGen :: StdGen -&gt; IO ()</code></h3><p>初始化或者设置全局生成器，我们可以用 <code>mkStdGen</code> 来生成随机种子。因此，有一个很傻瓜式的用法：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">setStdGen</span> (mkStdGen <span class="number">42</span>)</div></pre></td></tr></table></figure>
<p>当然，你可以用任意的 <code>Int</code> 来替换 <code>42</code>。</p>
<p>其实，你可以选择是否调用 <code>setStdGen</code>，如果你不调用的话，全局的生成器还是可用的。因为在 runtime 会在启动的时候用一个任意的种子去初始化它，所以每次启动的时候，都会有一个不同的种子。</p>
<h3 id="randomRIO-Random-a-gt-a-a-gt-IO-a"><a href="#randomRIO-Random-a-gt-a-a-gt-IO-a" class="headerlink" title="randomRIO :: (Random a) =&gt; (a,a) -&gt; IO a"></a><code>randomRIO :: (Random a) =&gt; (a,a) -&gt; IO a</code></h3><p>在给定范围随机返回一个类型为 <code>a</code> 的值，同时全局生成器也会更新。你可以通过一个元组来指定范围。下面这个例子会返回 <code>a</code> 到 <code>z</code> 之间的随机值（包含 <code>a</code> 和 <code>z</code>）：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">c</span> &lt;- randomRIO ('a', 'z')</div></pre></td></tr></table></figure>
<p><code>a</code> 可以是任意类型吗？并非如此。在 Haskell 98 标准中， <code>Random</code> 库只支持 <code>Bool</code>, <code>Char</code>,  <code>Int</code>, <code>Integer</code>, <code>Float</code>, <code>Double</code>（你可以自己去扩展这个支持的范围，但这是另外一个话题了）。</p>
<h3 id="randomIO-Random-a-gt-IO-a"><a href="#randomIO-Random-a-gt-IO-a" class="headerlink" title="randomIO :: (Random a) =&gt; IO a"></a><code>randomIO :: (Random a) =&gt; IO a</code></h3><p>返回一个类型为 <code>a</code> 的随机数（<code>a</code> 可以是任意类型吗？看上文），全局的生成器也会更新。下面这个例子会返回一个 <code>Double</code> 类型的随机数：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">x</span> &lt;- randomIO :: <span class="type">IO</span> <span class="type">Double</span></div></pre></td></tr></table></figure>
<p>随机数返回的范围由类型决定。</p>
<p>需要注意的是，这些都是 IO 函数，因此你只可以在 IO 函数中使用它们。换句话说，如果你写了一个要使用它们的函数，它的返回类型也会变成是 IO 函数。</p>
<p>举个例子，上面提到的代码片段都要写在 <code>do block</code> 中。这只是一个提醒，因为我们想要用命令式的方式来生成随机数。</p>
<p>下面这个例子展示如何在 IO monad 中完成之前的任务：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> System.Random</div><div class="line"></div><div class="line"><span class="title">main</span> = <span class="keyword">do</span></div><div class="line">    setStdGen (mkStdGen <span class="number">42</span>)  <span class="comment">-- 这步是可选的，如果有这一步，你每一次运行的结果都是一样的，因为随机种子固定是 42</span></div><div class="line">    s &lt;- randomStuff</div><div class="line">    print s</div><div class="line"></div><div class="line"><span class="title">randomStuff</span> :: <span class="type">IO</span> [<span class="type">Float</span>]</div><div class="line"><span class="title">randomStuff</span> = <span class="keyword">do</span></div><div class="line">    n &lt;- randomRIO (<span class="number">1</span>, <span class="number">7</span>)</div><div class="line">    sequence (replicate n (randomRIO (<span class="number">0</span>, <span class="number">1</span>)))</div></pre></td></tr></table></figure>
<h2 id="纯函数式"><a href="#纯函数式" class="headerlink" title="纯函数式"></a>纯函数式</h2><p>你可能有以下原因想知道如何用函数式的方式生成随机数：</p>
<ul>
<li>你有好奇心</li>
<li>你不想用 IO monad</li>
<li>因为一些并发或者其他原因，你想几个生成器同时存在，共享全局生成器不能解决你的问题</li>
</ul>
<p>实际上，有两种方法来用函数式的方式去生成随机数：</p>
<ul>
<li>从 stream（无限列表） 中提取随机数</li>
<li>把生成器当成函数参数的一部分，然后返回随机数</li>
</ul>
<p>这里有一些常用的函数用来创建生成器和包含随机数的无限列表。</p>
<h3 id="mkStdGen-Int-gt-StdGen"><a href="#mkStdGen-Int-gt-StdGen" class="headerlink" title="mkStdGen :: Int -&gt; StdGen"></a><code>mkStdGen :: Int -&gt; StdGen</code></h3><p>用随机种子创建生成器。</p>
<h3 id="randomRs-Random-a-RandomGen-g-gt-a-a-gt-g-gt-a"><a href="#randomRs-Random-a-RandomGen-g-gt-a-a-gt-g-gt-a" class="headerlink" title="randomRs :: (Random a, RandomGen g) =&gt; (a, a) -&gt; g -&gt; [a]"></a><code>randomRs :: (Random a, RandomGen g) =&gt; (a, a) -&gt; g -&gt; [a]</code></h3><p>用生成器生成给定范围的无限列表。例子：用 <code>42</code> 作为随机种子，返回 <code>a</code> 到 <code>z</code> 之间包含 <code>a</code> 和 <code>z</code> 的无限列表：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">randomRs</span> ('a', 'z') (mkStdGen <span class="number">42</span>)</div></pre></td></tr></table></figure>
<p>类型 <code>a</code> 是随机数的类型。类型 <code>g</code> 看起来是通用的，但实际上它总是 <code>StdGen</code>。</p>
<h3 id="randoms-Random-a-RandomGen-g-gt-g-gt-a"><a href="#randoms-Random-a-RandomGen-g-gt-g-gt-a" class="headerlink" title="randoms :: (Random a, RandomGen g) =&gt; g -&gt; [a]"></a><code>randoms :: (Random a, RandomGen g) =&gt; g -&gt; [a]</code></h3><p>用给定的生成器生成随机数的无限列表。例如：用 <code>42</code> 作为随机种子生成 <code>Double</code> 类型的列表：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">randoms</span> (mkStdGen <span class="number">42</span>) :: [<span class="type">Double</span>]</div></pre></td></tr></table></figure>
<p>随机数的范围由类型决定，你需要查文档来确定具体范围，或者直接用 <code>randomRs</code>。</p>
<p>注意，这些都是函数式的 —— 意味着这里面没有副作用，特别是生成器并不会更新。如果你用一个生成器去生成第一个列表，然后用相同的生成器去生成第二个列表…</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">g</span> = mkStdGen <span class="number">42</span></div><div class="line"><span class="title">a</span> = randoms g :: [<span class="type">Double</span>]</div><div class="line"><span class="title">b</span> = randoms g :: [<span class="type">Double</span>]</div></pre></td></tr></table></figure>
<p>猜猜结果，由于透明引用，这两个列表的结果是一样的！（如果你想用一个随机种子来生成两个不同的列表，我等下告诉你一个方法）。</p>
<p>下面一种方法来完成创建 <code>1</code> 到 <code>7</code> 的随机列表：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> System.Random</div><div class="line"></div><div class="line"><span class="title">main</span> = <span class="keyword">do</span></div><div class="line">    <span class="keyword">let</span> g   = mkStdGen <span class="number">42</span></div><div class="line">    <span class="keyword">let</span> [s] = take <span class="number">1</span> (randomStuff g)</div><div class="line">    print s</div><div class="line"></div><div class="line"><span class="title">randomStuff</span> :: <span class="type">RandomGen</span> g =&gt; g -&gt; [[<span class="type">Float</span>]]</div><div class="line"><span class="title">randomStuff</span> g = work (randomRs (<span class="number">0.0</span>, <span class="number">1.0</span>) g)</div><div class="line"></div><div class="line"><span class="title">work</span> :: [<span class="type">Float</span>] -&gt; [[<span class="type">Float</span>]]</div><div class="line"><span class="title">work</span> (r:rs)      =</div><div class="line">    <span class="keyword">let</span> n        = truncate (r * <span class="number">7.0</span>) + <span class="number">1</span></div><div class="line">        (xs, ys) = splitAt n rs</div><div class="line">    <span class="keyword">in</span> xs : work ys</div></pre></td></tr></table></figure>
<p>除了必要的打印操作外，这是纯函数式的。它用生成器生成了无限列表，然后再用这个无限列表来生成另一个无限列表作为答案，最后取第一个作为返回值。</p>
<p>我这样做是因为尽管我们今天的人物是生成一个随机数，但你通常会需要很多个，我希望这个例子可以对你有点帮助。</p>
<p>上面的代码的工作原理是：用一个生成器，创建一个包含 <code>Float</code> 的无限列表。截取第一个值，并扩大这个值到 <code>1</code> 到 <code>7</code>，然后用剩下的列表来生成答案。换句话说，把输入的列表分成 <code>(r:rs)</code>，<code>r</code> 决定生成列表的长度（<code>1</code> 到 <code>7</code>），<code>rs</code> 之后会被计算答案。</p>
<h3 id="split-RandomGen-g-gt-g-gt-g-g"><a href="#split-RandomGen-g-gt-g-gt-g-g" class="headerlink" title="split :: (RandomGen g) =&gt; g -&gt; (g, g)"></a><code>split :: (RandomGen g) =&gt; g -&gt; (g, g)</code></h3><p>用一个随机种子创建两个不同的生成器，其他情况下重用相同的种子是不明智的。</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">g</span> = mkStdGen <span class="number">42</span></div><div class="line">(ga, gb) = split g</div><div class="line"><span class="comment">-- do not use g elsewhere</span></div></pre></td></tr></table></figure>
<p>如果你想创建多余两个的生成器，你可以对新的生成器中的其中一个使用 <code>split</code>：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">g</span> = mkStdGen <span class="number">42</span></div><div class="line">(ga, g') = split g</div><div class="line">(gb, gc) = split g'</div><div class="line"><span class="comment">-- do not use g, g' elsewhere</span></div></pre></td></tr></table></figure>
<p>我们可以用 <code>split</code> 来获得两个生成器，这样我们就可以产生两个随机列表了。</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">randomStuff</span> :: <span class="type">RandomGen</span> g =&gt; g -&gt; [[<span class="type">Float</span>]]</div><div class="line"><span class="title">randomStuff</span> g = work (randomRs (<span class="number">1</span>, <span class="number">7</span>) ga) (randomRs (<span class="number">0.0</span>, <span class="number">1.0</span>) gb)</div><div class="line">    <span class="keyword">where</span> (ga,gb) = split g</div><div class="line"></div><div class="line"><span class="title">work</span> :: [<span class="type">Int</span>] -&gt; [<span class="type">Float</span>] -&gt; [[<span class="type">Float</span>]]</div><div class="line"><span class="title">work</span> (n:ns) rs =</div><div class="line">    <span class="keyword">let</span> (xs,ys) = splitAt n rs</div><div class="line">    <span class="keyword">in</span> xs : work ns ys</div></pre></td></tr></table></figure>
<p>它把生成器分成两个，然后产生两个列表。</p>
<p>我在主程序中硬编码了随机种子。正常情况下你可以在其他地方获取随机种子 —— 从输入中获取，从文件中获取，从时间上获取，或者从某些设备中获取。</p>
<p>这些在主程序中都是 do-able 的，因为它们都可以在 IO monad 中访问。</p>
<p>你也可以通过 <code>getStdGen</code> 获取全局生成器：</p>
<figure class="highlight hs"><table><tr><td class="code"><pre><div class="line"><span class="title">main</span> = <span class="keyword">do</span></div><div class="line">    g &lt;- getStdGen</div><div class="line">    <span class="keyword">let</span> [s] = take randomStuff g</div><div class="line">    print s</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.vex.net/~trebla/haskell/random.xhtml" target="_blank" rel="external">原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随机数（我指的是伪随机数）是通过显式或隐式的状态来生成的。这意味着在 Haskell 中，随机数的使用（通过 &lt;code&gt;System.Random&lt;/code&gt; 库）是伴随着状态的传递的。 &lt;/p&gt;
&lt;p&gt;大部分需要获得帮助的人都有命令式编程的背景，因此，我会先用命令式的
    
    </summary>
    
      <category term="haskell" scheme="http://scarletsky.github.io/categories/haskell/"/>
    
    
      <category term="haskell" scheme="http://scarletsky.github.io/tags/haskell/"/>
    
      <category term="random" scheme="http://scarletsky.github.io/tags/random/"/>
    
  </entry>
  
  <entry>
    <title>在 Node.js 中利用 js-xlsx 处理 Excel 文件</title>
    <link href="http://scarletsky.github.io/2016/01/30/nodejs-process-excel/"/>
    <id>http://scarletsky.github.io/2016/01/30/nodejs-process-excel/</id>
    <published>2016-01-30T03:31:46.000Z</published>
    <updated>2016-02-29T04:28:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍用 Node.js 中的 <code>js-xlsx</code> 库来处理 Excel 文件。<br><code>js-xlsx</code> 库是目前 Github 上 star 数量最多的处理 Excel 的库，功能强大，但上手难度稍大。文档有些乱，不适合快速上手。<br>本文对 <code>js-xlsx</code> 库进行一定的总结，并提供几个实用的例子供读者测试，学习，交流。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ npm install xlsx</div></pre></td></tr></table></figure>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>在使用这个库之前，先介绍库中的一些概念。</p>
<ul>
<li><p><code>workbook</code> 对象，指的是整份 Excel 文档。我们在使用 <code>js-xlsx</code> 读取 Excel 文档之后就会获得 <code>workbook</code> 对象。</p>
</li>
<li><p><code>worksheet</code> 对象，指的是 Excel 文档中的表。我们知道一份 Excel 文档中可以包含很多张表，而每张表对应的就是 <code>worksheet</code> 对象。</p>
</li>
<li><p><code>cell</code> 对象，指的就是 <code>worksheet</code> 中的单元格，一个单元格就是一个 <code>cell</code> 对象。</p>
</li>
</ul>
<p>它们的关系如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// workbook</span></div><div class="line">&#123;</div><div class="line">    <span class="attr">SheetNames</span>: [<span class="string">'sheet1'</span>, <span class="string">'sheet2'</span>],</div><div class="line">    <span class="attr">Sheets</span>: &#123;</div><div class="line">        <span class="comment">// worksheet</span></div><div class="line">        <span class="string">'sheet1'</span>: &#123;</div><div class="line">            <span class="comment">// cell</span></div><div class="line">            <span class="string">'A1'</span>: &#123; ... &#125;,</div><div class="line">            <span class="comment">// cell</span></div><div class="line">            <span class="string">'A2'</span>: &#123; ... &#125;,</div><div class="line">            ...</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// worksheet</span></div><div class="line">        <span class="string">'sheet2'</span>: &#123;</div><div class="line">            <span class="comment">// cell</span></div><div class="line">            <span class="string">'A1'</span>: &#123; ... &#125;,</div><div class="line">            <span class="comment">// cell</span></div><div class="line">            <span class="string">'A2'</span>: &#123; ... &#125;,</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol>
<li>用 <code>XLSX.readFile</code> 打开 Excel 文件，返回 <code>workbook</code></li>
<li>用 <code>workbook.SheetNames</code> 获取表名</li>
<li>用 <code>workbook.Sheets[xxx]</code> 通过表名获取表格</li>
<li>按自己的需求去处理表格</li>
<li>生成新的 Excel 文件</li>
</ol>
<h3 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h3><p>读取 Excel 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> XLSX <span class="keyword">from</span> <span class="string">'xlsx'</span>;</div><div class="line"><span class="keyword">const</span> workbook = XLSX.readFile(<span class="string">'someExcel.xlsx'</span>, opts);</div></pre></td></tr></table></figure>
<p>获取 Excel 文件中的表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取 Excel 中所有表名</span></div><div class="line"><span class="keyword">const</span> sheetNames = workbook.SheetNames; <span class="comment">// 返回 ['sheet1', 'sheet2']</span></div><div class="line"><span class="comment">// 根据表名获取对应某张表</span></div><div class="line"><span class="keyword">const</span> worksheet = workbook.Sheets[sheetNames[<span class="number">0</span>]];</div></pre></td></tr></table></figure>
<p>通过 <code>worksheet[address]</code> 来操作表格，以 <code>!</code> 开头的 key 是特殊的字段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取 A1 单元格对象</span></div><div class="line"><span class="keyword">let</span> a1 = worksheet[<span class="string">'A1'</span>]; <span class="comment">// 返回 &#123; v: 'hello', t: 's', ... &#125;</span></div><div class="line"><span class="comment">// 获取 A1 中的值</span></div><div class="line">a1.v <span class="comment">// 返回 'hello'</span></div><div class="line"></div><div class="line"><span class="comment">// 获取表的有效范围</span></div><div class="line">worksheet[<span class="string">'!ref'</span>] <span class="comment">// 返回 'A1:B20'</span></div><div class="line">worksheet[<span class="string">'!range'</span>] <span class="comment">// 返回 range 对象，&#123; s: &#123; r: 0, c: 0&#125;, e: &#123; r: 100, c: 2 &#125; &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 获取合并过的单元格</span></div><div class="line">worksheet[<span class="string">'!merges'</span>] <span class="comment">// 返回一个包含 range 对象的列表，[ &#123;s: &#123; r: 0, c: 0 &#125;, c: &#123; r: 2, c: 1 &#125; &#125; ]</span></div></pre></td></tr></table></figure>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="解析-Excel-生成-JSON"><a href="#解析-Excel-生成-JSON" class="headerlink" title="解析 Excel 生成 JSON"></a>解析 Excel 生成 JSON</h4><blockquote>
<p><strong>Tips</strong> 事实上，你可以直接通过 <code>XLSX.utils.sheet_to_json(worksheet)</code> 获得同样的结果</p>
</blockquote>
<p><strong>注意</strong> 本例子中假设表的第一行为字段名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> headers = &#123;&#125;;</div><div class="line"><span class="keyword">const</span> data = [];</div><div class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(worksheet);</div><div class="line">keys</div><div class="line">    <span class="comment">// 过滤以 ! 开头的 key</span></div><div class="line">    .filter(<span class="function"><span class="params">k</span> =&gt;</span> k[<span class="number">0</span>] !== <span class="string">'!'</span>)</div><div class="line">    <span class="comment">// 遍历所有单元格</span></div><div class="line">    .forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">// 如 A11 中的 A</span></div><div class="line">        <span class="keyword">let</span> col = k.substring(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">        <span class="comment">// 如 A11 中的 11</span></div><div class="line">        <span class="keyword">let</span> row = <span class="built_in">parseInt</span>(k.substring(<span class="number">1</span>));</div><div class="line">        <span class="comment">// 当前单元格的值</span></div><div class="line">        <span class="keyword">let</span> value = worksheet[k].v;</div><div class="line"></div><div class="line">        <span class="comment">// 保存字段名</span></div><div class="line">        <span class="keyword">if</span> (row === <span class="number">1</span>) &#123;</div><div class="line">            headers[col] = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 解析成 JSON</span></div><div class="line">        <span class="keyword">if</span> (!data[row]) &#123;</div><div class="line">            data[row] = &#123;&#125;;</div><div class="line">        &#125;</div><div class="line">        data[row][headers[col]] = value;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(data); <span class="comment">// [ &#123; '姓名': 'test1', '年龄': 20 &#125;, &#123; '姓名': 'test2', '年龄': 10 &#125; ... ]</span></div></pre></td></tr></table></figure>
<h4 id="合并表格"><a href="#合并表格" class="headerlink" title="合并表格"></a>合并表格</h4><p>步骤：</p>
<ol>
<li>读取多份表格</li>
<li>合并数组</li>
</ol>
<p><strong>Tips:</strong> 其实合并表格跟 <code>XLSX</code> 没什么关系，只是处理几个数组而已。</p>
<p>sheet1</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>test1</td>
<td>30</td>
</tr>
<tr>
<td>2</td>
<td>test2</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>test3</td>
<td>18</td>
</tr>
</tbody>
</table>
<p>sheet2</p>
<table>
<thead>
<tr>
<th>id</th>
<th>country</th>
<th>remark</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>China</td>
<td>hello</td>
</tr>
<tr>
<td>2</td>
<td>America</td>
<td>world</td>
</tr>
<tr>
<td>3</td>
<td>Unkonw</td>
<td>???</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> sheet1 = XLSX.utils.sheet_to_json(sheet1);</div><div class="line"><span class="keyword">let</span> sheet2 = XLSX.utils.sheet_to_json(sheet2);</div><div class="line"></div><div class="line"><span class="comment">// 先合并 sheet1 和 sheet2，再对统一处理</span></div><div class="line"><span class="keyword">const</span> result = sheet1.concat(sheet2).reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> index = prev.findIndex(<span class="function">(<span class="params">elem, i</span>) =&gt;</span> elem.id === next.id);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> prev.concat(next);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        prev[index] = <span class="built_in">Object</span>.assign(&#123;&#125;, prev[index], next);</div><div class="line">        <span class="keyword">return</span> prev;</div><div class="line">    &#125;</div><div class="line">&#125;, []);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"></div><div class="line"><span class="comment">// [ &#123; id: '1',</span></div><div class="line"><span class="comment">//    name: 'test1',</span></div><div class="line"><span class="comment">//    age: '30',</span></div><div class="line"><span class="comment">//    country: 'China',</span></div><div class="line"><span class="comment">//    remark: 'hello' &#125;,</span></div><div class="line"><span class="comment">//  &#123; id: '2',</span></div><div class="line"><span class="comment">//    name: 'test2',</span></div><div class="line"><span class="comment">//    age: '20',</span></div><div class="line"><span class="comment">//    country: 'America',</span></div><div class="line"><span class="comment">//    remark: 'world' &#125;,</span></div><div class="line"><span class="comment">//  &#123; id: '3',</span></div><div class="line"><span class="comment">//    name: 'test3',</span></div><div class="line"><span class="comment">//    age: '18',</span></div><div class="line"><span class="comment">//    country: 'Unkonw',</span></div><div class="line"><span class="comment">//    remark: '???' &#125; ]</span></div></pre></td></tr></table></figure>
<h4 id="导出表格"><a href="#导出表格" class="headerlink" title="导出表格"></a>导出表格</h4><p>步骤：</p>
<ol>
<li>构建特定的数据结构，如下。</li>
<li>调用 <code>XLSX.writeFile(workbook, filename)</code> 即可。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// workbook</span></div><div class="line">&#123;</div><div class="line">    <span class="attr">SheetNames</span>: [<span class="string">'mySheet'</span>],</div><div class="line">    <span class="attr">Sheets</span>: &#123;</div><div class="line">        <span class="string">'mySheet'</span>: &#123;</div><div class="line">            <span class="string">'!ref'</span>: <span class="string">'A1:E4'</span>, <span class="comment">// 必须要有这个范围才能输出，否则导出的 excel 会是一个空表</span></div><div class="line">            A1: &#123; <span class="attr">v</span>: <span class="string">'id'</span> &#125;,</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> _headers = [<span class="string">'id'</span>, <span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'country'</span>, <span class="string">'remark'</span>]</div><div class="line"><span class="keyword">var</span> _data = [ &#123; <span class="attr">id</span>: <span class="string">'1'</span>,</div><div class="line">                <span class="attr">name</span>: <span class="string">'test1'</span>,</div><div class="line">                <span class="attr">age</span>: <span class="string">'30'</span>,</div><div class="line">                <span class="attr">country</span>: <span class="string">'China'</span>,</div><div class="line">                <span class="attr">remark</span>: <span class="string">'hello'</span> &#125;,</div><div class="line">              &#123; <span class="attr">id</span>: <span class="string">'2'</span>,</div><div class="line">                <span class="attr">name</span>: <span class="string">'test2'</span>,</div><div class="line">                <span class="attr">age</span>: <span class="string">'20'</span>,</div><div class="line">                <span class="attr">country</span>: <span class="string">'America'</span>,</div><div class="line">                <span class="attr">remark</span>: <span class="string">'world'</span> &#125;,</div><div class="line">              &#123; <span class="attr">id</span>: <span class="string">'3'</span>,</div><div class="line">                <span class="attr">name</span>: <span class="string">'test3'</span>,</div><div class="line">                <span class="attr">age</span>: <span class="string">'18'</span>,</div><div class="line">                <span class="attr">country</span>: <span class="string">'Unkonw'</span>,</div><div class="line">                <span class="attr">remark</span>: <span class="string">'???'</span> &#125; ];</div><div class="line"></div><div class="line"><span class="keyword">var</span> headers = _headers</div><div class="line">                <span class="comment">// 为 _headers 添加对应的单元格位置</span></div><div class="line">                <span class="comment">// [ &#123; v: 'id', position: 'A1' &#125;,</span></div><div class="line">                <span class="comment">//   &#123; v: 'name', position: 'B1' &#125;,</span></div><div class="line">                <span class="comment">//   &#123; v: 'age', position: 'C1' &#125;,</span></div><div class="line">                <span class="comment">//   &#123; v: 'country', position: 'D1' &#125;,</span></div><div class="line">                <span class="comment">//   &#123; v: 'remark', position: 'E1' &#125; ]</span></div><div class="line">                .map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">v</span>: v, <span class="attr">position</span>: <span class="built_in">String</span>.fromCharCode(<span class="number">65</span>+i) + <span class="number">1</span> &#125;))</div><div class="line">                <span class="comment">// 转换成 worksheet 需要的结构</span></div><div class="line">                <span class="comment">// &#123; A1: &#123; v: 'id' &#125;,</span></div><div class="line">                <span class="comment">//   B1: &#123; v: 'name' &#125;,</span></div><div class="line">                <span class="comment">//   C1: &#123; v: 'age' &#125;,</span></div><div class="line">                <span class="comment">//   D1: &#123; v: 'country' &#125;,</span></div><div class="line">                <span class="comment">//   E1: &#123; v: 'remark' &#125; &#125;</span></div><div class="line">                .reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, prev, &#123;[next.position]: &#123;<span class="attr">v</span>: next.v&#125;&#125;), &#123;&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = _data</div><div class="line">              <span class="comment">// 匹配 headers 的位置，生成对应的单元格数据</span></div><div class="line">              <span class="comment">// [ [ &#123; v: '1', position: 'A2' &#125;,</span></div><div class="line">              <span class="comment">//     &#123; v: 'test1', position: 'B2' &#125;,</span></div><div class="line">              <span class="comment">//     &#123; v: '30', position: 'C2' &#125;,</span></div><div class="line">              <span class="comment">//     &#123; v: 'China', position: 'D2' &#125;,</span></div><div class="line">              <span class="comment">//     &#123; v: 'hello', position: 'E2' &#125; ],</span></div><div class="line">              <span class="comment">//   [ &#123; v: '2', position: 'A3' &#125;,</span></div><div class="line">              <span class="comment">//     &#123; v: 'test2', position: 'B3' &#125;,</span></div><div class="line">              <span class="comment">//     &#123; v: '20', position: 'C3' &#125;,</span></div><div class="line">              <span class="comment">//     &#123; v: 'America', position: 'D3' &#125;,</span></div><div class="line">              <span class="comment">//     &#123; v: 'world', position: 'E3' &#125; ],</span></div><div class="line">              <span class="comment">//   [ &#123; v: '3', position: 'A4' &#125;,</span></div><div class="line">              <span class="comment">//     &#123; v: 'test3', position: 'B4' &#125;,</span></div><div class="line">              <span class="comment">//     &#123; v: '18', position: 'C4' &#125;,</span></div><div class="line">              <span class="comment">//     &#123; v: 'Unkonw', position: 'D4' &#125;,</span></div><div class="line">              <span class="comment">//     &#123; v: '???', position: 'E4' &#125; ] ]</span></div><div class="line">              .map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> _headers.map(<span class="function">(<span class="params">k, j</span>) =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, &#123; <span class="attr">v</span>: v[k], <span class="attr">position</span>: <span class="built_in">String</span>.fromCharCode(<span class="number">65</span>+j) + (i+<span class="number">2</span>) &#125;)))</div><div class="line">              <span class="comment">// 对刚才的结果进行降维处理（二维数组变成一维数组）</span></div><div class="line">              <span class="comment">// [ &#123; v: '1', position: 'A2' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: 'test1', position: 'B2' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: '30', position: 'C2' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: 'China', position: 'D2' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: 'hello', position: 'E2' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: '2', position: 'A3' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: 'test2', position: 'B3' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: '20', position: 'C3' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: 'America', position: 'D3' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: 'world', position: 'E3' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: '3', position: 'A4' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: 'test3', position: 'B4' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: '18', position: 'C4' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: 'Unkonw', position: 'D4' &#125;,</span></div><div class="line">              <span class="comment">//   &#123; v: '???', position: 'E4' &#125; ]</span></div><div class="line">              .reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev.concat(next))</div><div class="line">              <span class="comment">// 转换成 worksheet 需要的结构</span></div><div class="line">              <span class="comment">//   &#123; A2: &#123; v: '1' &#125;,</span></div><div class="line">              <span class="comment">//     B2: &#123; v: 'test1' &#125;,</span></div><div class="line">              <span class="comment">//     C2: &#123; v: '30' &#125;,</span></div><div class="line">              <span class="comment">//     D2: &#123; v: 'China' &#125;,</span></div><div class="line">              <span class="comment">//     E2: &#123; v: 'hello' &#125;,</span></div><div class="line">              <span class="comment">//     A3: &#123; v: '2' &#125;,</span></div><div class="line">              <span class="comment">//     B3: &#123; v: 'test2' &#125;,</span></div><div class="line">              <span class="comment">//     C3: &#123; v: '20' &#125;,</span></div><div class="line">              <span class="comment">//     D3: &#123; v: 'America' &#125;,</span></div><div class="line">              <span class="comment">//     E3: &#123; v: 'world' &#125;,</span></div><div class="line">              <span class="comment">//     A4: &#123; v: '3' &#125;,</span></div><div class="line">              <span class="comment">//     B4: &#123; v: 'test3' &#125;,</span></div><div class="line">              <span class="comment">//     C4: &#123; v: '18' &#125;,</span></div><div class="line">              <span class="comment">//     D4: &#123; v: 'Unkonw' &#125;,</span></div><div class="line">              <span class="comment">//     E4: &#123; v: '???' &#125; &#125;</span></div><div class="line">              .reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, prev, &#123;[next.position]: &#123;<span class="attr">v</span>: next.v&#125;&#125;), &#123;&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 合并 headers 和 data</span></div><div class="line"><span class="keyword">var</span> output = <span class="built_in">Object</span>.assign(&#123;&#125;, headers, data);</div><div class="line"><span class="comment">// 获取所有单元格的位置</span></div><div class="line"><span class="keyword">var</span> outputPos = <span class="built_in">Object</span>.keys(output);</div><div class="line"><span class="comment">// 计算出范围</span></div><div class="line"><span class="keyword">var</span> ref = outputPos[<span class="number">0</span>] + <span class="string">':'</span> + outputPos[outputPos.length - <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// 构建 workbook 对象</span></div><div class="line"><span class="keyword">var</span> wb = &#123;</div><div class="line">    <span class="attr">SheetNames</span>: [<span class="string">'mySheet'</span>],</div><div class="line">    <span class="attr">Sheets</span>: &#123;</div><div class="line">        <span class="string">'mySheet'</span>: <span class="built_in">Object</span>.assign(&#123;&#125;, output, &#123; <span class="string">'!ref'</span>: ref &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 导出 Excel</span></div><div class="line">XLSX.writeFile(wb, <span class="string">'output.xlsx'</span>);</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/SheetJS/js-xlsx" target="_blank" rel="external">https://github.com/SheetJS/js-xlsx</a><br><a href="http://stackoverflow.com/questions/30859901/parse-xlsx-with-node-and-create-json" target="_blank" rel="external">http://stackoverflow.com/questions/30859901/parse-xlsx-with-node-and-create-json</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文介绍用 Node.js 中的 &lt;code&gt;js-xlsx&lt;/code&gt; 库来处理 Excel 文件。&lt;br&gt;&lt;code&gt;js-xlsx&lt;
    
    </summary>
    
      <category term="javascript" scheme="http://scarletsky.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://scarletsky.github.io/tags/javascript/"/>
    
      <category term="node" scheme="http://scarletsky.github.io/tags/node/"/>
    
      <category term="excel" scheme="http://scarletsky.github.io/tags/excel/"/>
    
      <category term="js-xlsx" scheme="http://scarletsky.github.io/tags/js-xlsx/"/>
    
  </entry>
  
</feed>
